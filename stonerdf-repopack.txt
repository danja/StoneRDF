================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-07-28T00:56:54.492Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.
- Code comments have been removed.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

Additional User-Provided Header:
--------------------------------
StoneRDF repo

================================================================
Repository Files
================================================================

================
File: BaselineOfStoneRDF.package/.filetree
================
{"packageExtension" : ".package",
"propertyFileExtension" : ".json" }

================
File: BaselineOfStoneRDF.package/BaselineOfStoneRDF.class.st
================
BaselineOf subclass: #BaselineOfStoneRDF
    instanceVariableNames: ''
    classVariableNames: ''
    package: 'BaselineOfStoneRDF'

{ #category : #baselines }
BaselineOfStoneRDF >> baseline: spec [
    <baseline>
    spec for: #common do: [
        "Define your project structure here"
        spec 
            package: 'StoneRDF-Core';
            package: 'StoneRDF-Tests' with: [ spec requires: #('StoneRDF-Core') ].
        spec 
            group: 'default' with: #('Core' 'Tests');
            group: 'Core' with: #('StoneRDF-Core');
            group: 'Tests' with: #('StoneRDF-Tests')
    ]
]

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# StoneRDF

_it might not happen_

This is a simple RDF library implementation in Smalltalk, primarily targetted at Pharo.

================
File: docs/notes.md
================
```
repopack --verbose -c ./repopack.config.json
```

================
File: docs/pharo-manual-baselines.md
================
# Baselines

Pharo projects often require a configuration to declare how they should be loaded. This configuration is done via **Baselines**. A baseline defines the packages of the project, their dependencies to each other and to external projects and independent sub-groups that can be loaded.

Adding a baseline to a project has some advantages:

- It makes it easier to load the project
- It makes it easier for others to contribute to your project
- It allows the users of the project to be unaware of the project's dependencies
- It makes explicit the dependencies of the project
- It ensures that packages and dependencies of the project are loaded in the right order

This documentation explains how to write a baseline and how to load the project described by this baseline.

- [Baselines](#baselines)
  - [How to define Baselines](#how-to-define-baselines)
    - [Define packages forming your project](#define-packages-forming-your-project)
    - [Define external dependencies](#define-external-dependencies)
      - [To other remote git projects](#to-other-remote-git-projects)
        - [Depend on a subset of a git project](#depend-on-a-subset-of-a-git-project)
        - [Depends on the same project with different groups](#depends-on-the-same-project-with-different-groups)
      - [To a local git project](#to-a-local-git-project)
      - [To smalltalkhub projects](#to-smalltalkhub-projects)
    - [Groups](#groups)
      - [The default group](#the-default-group)
    - [Pre/post load actions](#prepost-load-actions)
    - [Loads different packages depending on the Pharo version](#loads-different-packages-depending-on-the-pharo-version)
    - [Define custom attributes](#define-custom-attributes)
    - [Loading types](#loading-types)
      - [Linear loading](#linear-loading)
      - [Atomic loading](#atomic-loading)
    - [Full example](#full-example)
  - [How to load a git project using its baseline](#how-to-load-a-git-project-using-its-baseline)
    - [From the playground](#from-the-playground)
      - [Project managed with Git](#project-managed-with-git)
        - [Project from github/gitlab/bitbucket](#project-from-githubgitlabbitbucket)
        - [Project from local repository](#project-from-local-repository)
      - [Project managed with Smalltalkhub](#project-managed-with-smalltalkhub)
      - [Project without repository](#project-without-repository)
      - [Loading groups](#loading-groups)
      - [Conflict, Upgrade and Downgrade resolution](#conflict-upgrade-and-downgrade-resolution)
      - [Manage warnings](#manage-warnings)
    - [From Iceberg](#from-iceberg)
  - [Other features](#other-features)
    - [Metacello lock feature](#metacello-lock-feature)
    - [Metacello get feature](#metacello-get-feature)
    - [Metacello fetch feature](#metacello-fetch-feature)
    - [Metacello record feature](#metacello-record-feature)
    - [Metacello listing feature](#metacello-listing-feature)
  - [See also](#see-also)

## How to define Baselines

The first step to create a baseline is to create a new subclass of `BaselineOf`. In the following example, `MyProject` is to be substituted by the name of your project:

```Smalltalk
BaselineOf subclass: #BaselineOfMyProject
	slots: {  }
	classVariables: {  }
	package: 'BaselineOfMyProject'
```

This class should be in a package separated from other packages' projects. The package holding the baseline **must** have the same name as the baseline. To summarize, `BaselineOfMyProject` class is in the `BaselineOfMyProject` package.

Then, create a method that defines the spec of the project for the commit it will be included in.

```Smalltalk
baseline: spec
	<baseline>
	spec
		for: #common
		do: [
			"The main code of the baseline will go here"
		]
```

> The name of this method does not have to be `#baseline:`; however, that is the name that is commonly used. In fact, it is the `<baseline>` pragma which specifies that the method defines the spec of the project.

If your project is stored using a metadataless format (Tonel or FileTree metadataless), which is the default since Pharo 6, you need to add this method to your baseline:

```Smalltalk
projectClass
	^ MetacelloCypressBaselineProject
```

Or, if the project should be loadable in Pharo < 6.1, use this version:

```Smalltalk
projectClass
	^ [ self class environment at: #MetacelloCypressBaselineProject ]
	on: NotFound
	do: [ super projectClass ]
```

> The method is common to all projets using the metadataless format and the class return does not depend on the name of your baseline.

This will allow Metacello to be able to update your project and is needed because the default project class of Metacello used metadata to know if an update was needed.

### Define packages forming your project

To define the packages of the project, send the message `#package:` to the spec with the name of the package as argument.

```Smalltalk
baseline: spec
	<baseline>
	spec
		for: #common
		do: [
			"Packages"
			spec
				package: 'MyProject';
				package: 'MyProject-Tests';
				package: 'MyProject-Gui';
				package: 'MyProject-Gui-Tests';
				package: 'MyProject-Examples' ]
```

> Note: Packages are the most atomic entities managed by the baseline. It is not possible to declare entities at the package-tag granularity.

Defining packages is not enough to load them, because some of them might depend on other packages/projects. For example, `MyProject-Tests` needs to be loaded after `MyProject`.

To manage dependencies that are external to a project, see section _[Define external dependencies](#define-external-dependencies)_.

For dependencies between the packages of your project, you can use the message `#package:with:` to give more information to the spec.

```Smalltalk
baseline: spec
	<baseline>
	spec
		for: #common
			do: [
				"Packages"
				spec
					package: 'MyProject';
					package: 'MyProject-Tests' with: [ spec requires: #('MyProject') ];
					package: 'MyProject-Gui' with: [ spec requires: #('MyProject') ];
					package: 'MyProject-Gui-Tests' with: [ spec requires: #('MyProject-Tests') ];
					package: 'MyProject-Examples' with: [ spec requires: #('MyProject-Gui') ] ]
```

The method `#requires:` will define the list of dependencies of a specific package.

Another way to declare requirements is to use the method `#includes:`. This method takes a collection of declarations as a parameter and will notify Metacello that all of them should include the package if they are loaded. This is helpful when defining platform-specific requirements, in case we want one of our packages to come with a platform-dependant package, which is depending on this package. See example in section _[Loads different packages depending on the Pharo version](#loads-different-packages-depending-on-the-pharo-version)_.

### Define external dependencies

Defining external dependencies can be done in different ways depending on where the dependency is hosted.

> To improve readability, I recommend extracting the definitions of dependencies into separate methods.

#### To other remote git projects

To depend on a git project, you can use the method `#baseline:with:`.

```Smalltalk
spec
	baseline: '{BaselineName}'
	with: [ spec repository: '{prefix}://{url}:{owner}/{projectName}:{version}/{subfolder}' ]
```

This snippet should be configured with:

- `{BaselineName}`: The name of the baseline to load (e.g, `'MaterialDesignLite'` to load `BaselineOfMaterialDesignLite`)
- `{prefix}`: This is host-specific:
  - `github` for github
  - `bitbucket` for bitbucket
  - `gitlab` for gitlab
  - `git` for others (and {url} is thus mandatory)
- `{url}`: Base url to the git host. Mandatory when prefix `git` is used, optional for other prefixes (can be useful for self hosted gitlab for example)
- `{owner}`: Name of the user or organization hosting the project
- `{projectName}`: Name of the project
- `{version}`: This parameter is optional (defaults to master). It can be the name of a branch, a tag like `'v1.2.0'` or `'v1.x.x'`, or a the SHA of a commit
- `{subfolder}`: This parameter is optional in case the code is not at the root of the project. It should point to the sub-folder containing the code

Example:

```Smalltalk
spec
	baseline: 'MaterialDesignLite'
	with: [ spec repository: 'github://DuneSt/MaterialDesignLite:v1.x.x/src']
```

##### Depend on a subset of a git project

Some projects can defines `groups` in their baselines. They are subsets of the project that can be loaded independently.
The previous snippet can also be customized to load only a specific group of the dependency like this:

```Smalltalk
spec
	baseline: 'MaterialDesignLite'
	with: [
		spec
		loads: #('Extensions');
		repository: 'github://DuneSt/MaterialDesignLite:v1.x.x/src'
	]
```

Once the dependency is defined, add `BaselineName` to the list of the required dependencies of the package depending on it.

Example:

```Smalltalk
baseline: spec
	<baseline>
	spec
		for: #common
		do: [
			"Dependencies"
			self materialDesignLite: spec.

			"Packages"
			spec
				package: 'MyProject';
				package: 'MyProject-Tests' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui' with: [ spec requires: #('MyProject' 'MaterialDesignLite') ];
				package: 'MyProject-Gui-Tests' with: [ spec requires: #('MyProject-Tests') ];
				package: 'MyProject-Examples' with: [ spec requires: #('MyProject-Gui') ] ].
```

```Smalltalk
materialDesignLite: spec
	spec
		baseline: 'MaterialDesignLite'
		with: [
			spec
				loads: #('Extensions');
				repository: 'github://DuneSt/MaterialDesignLite:v1.x.x/src'
		]
```

##### Depends on the same project with different groups

In some cases your project might depend on an external project, but two packages of your project depend on different groups of this external project.

You can use the message `#project:copyFrom:with:` to create a new dependency spec.

```Smalltalk
materialDesignLite: spec
	spec
		baseline: 'MaterialDesignLite' with: [ spec repository: 'github://DuneSt/MaterialDesignLite:v1.x.x/src' ];
		project: 'MaterialDesignLiteExtensions' copyFrom: 'MaterialDesignLite' with: [ spec loads: #('Extensions') ]
```

Then you can use the new project name in the specification of dependencies.

Example:

```Smalltalk
baseline: spec
	<baseline>
	spec
		for: #common
		do: [
			"Dependencies"
			self materialDesignLite: spec.

			"Packages"
			spec
				package: 'MyProject';
				package: 'MyProject-Tests' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui' with: [ spec requires: #('MyProject' 'MaterialDesignLiteExtensions') ];
				package: 'MyProject-Gui-Tests' with: [ spec requires: #('MyProject-Tests' 'MaterialDesignLite' "We load the version containing MDL tests for our tests only") ];
				package: 'MyProject-Examples' with: [ spec requires: #('MyProject-Gui') ] ].
```

```Smalltalk
materialDesignLite: spec
	spec
		baseline: 'MaterialDesignLite' with: [ spec repository: 'github://DuneSt/MaterialDesignLite:v1.x.x/src' ];
		project: 'MaterialDesignLiteExtensions' copyFrom: 'MaterialDesignLite' with: [ spec loads: #('Extensions') ]
```

#### To a local git project

Sometimes we do not have access to a network, so we want to define dependencies to local git repositories.

This works like in the previous section, but with this repository format:

```Smalltalk
spec
	baseline: 'MaterialDesignLite'
	with: [ spec repository: 'gitlocal://full/path/to/repository' ]
```

#### To smalltalkhub projects

Depending on a [Smalltalkhub](http://smalltalkhub.com) project is done via `#project:with`.

```Smalltalk
spec
	project: '{DependencyName}'
	with: [ spec
		className: #ConfigurationOf{ConfigurationName};
		versionString: #'{Version}';
		repository: 'http://smalltalkhub.com/mc/{owner}/{repositoryName}/main/' ]
```

The snippet should be configured with:

- `{DependencyName}`: It can be anything from your packages, groups and other dependencies names. It will be used to define dependency to this project in your packages/groups
- `{ConfigurationName}`: It is the name of the configuration you wish to reference
- `{Version}`: Name of the version you wish to reference. It can be something like `'development'`, `'stable'`, `'release1'`, `'1.2.6'`, `'1.0-baseline'`, etc.
- `{owner}`: Name of the team or user hosting the project
- `{repositoryName}`: Name of the repository on SmalltalkHub

Example:

```Smalltalk
spec
	project: 'Magritte3'
	with: [ spec
		className: #ConfigurationOfMagritte3;
		versionString: #'release3';
		repository: 'http://smalltalkhub.com/mc/Magritte/Magritte3/main/' ]
```

As for git-hosted repositories, you can ask for a specific group:

```Smalltalk
spec
	project: 'Magritte3'
	with: [ spec
		className: #ConfigurationOfMagritte3;
		versionString: #'release3';
		loads: #('Seaside');
		repository: 'http://smalltalkhub.com/mc/Magritte/Magritte3/main/' ]
```

You can now use the dependency names to add the project as a dependency of your packages.

```Smalltalk
baseline: spec
	<baseline>
	spec
		for: #common
		do: [
			"Dependencies"
			self magritte3: spec.

			"Packages"
			spec
				package: 'MyProject';
				package: 'MyProject-Tests' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui' with: [ spec requires: #('MyProject' 'Magritte3') ];
				package: 'MyProject-Gui-Tests' with: [ spec requires: #('MyProject-Tests') ];
				package: 'MyProject-Examples' with: [ spec requires: #('MyProject-Gui') ] ].
```

```Smalltalk
magritte3: spec
	spec
		project: 'Magritte3'
		with: [ spec
			className: #ConfigurationOfMagritte3;
			versionString: #'release3';
			loads: #('Seaside');
			repository: 'http://smalltalkhub.com/mc/Magritte/Magritte3/main/' ]
```

### Groups

Sometimes we don't want to load the full project, but just a sub part, e.g.:

- Only the model of a project is needed without the UI (for example to build an alternative UI)
- Only the core of the project is needed without the tests and examples
- The project has some optional modules
- etc.

To manage such cases, baselines have the concept of a `Group`. A group is a loadable spec containing only a sub part of the project.

They can be declared with the `#group:with:` message. The second parameter defines the content of the group. The content can either be a package name, a dependency name, or even another group name.

Example:

```Smalltalk
baseline: spec
	<baseline>
	spec
		for: #common
		do: [
			"Packages"
			spec
				package: 'MyProject';
				package: 'MyProject-Tests' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui-Tests' with: [ spec requires: #('MyProject-Tests') ];
				package: 'MyProject-Examples' with: [ spec requires: #('MyProject-Gui') ] ].

			"Groups"
			spec
				group: 'Model' with: #('MyProject');
				group: 'Tests' with: #('MyProject-Tests' 'MyProject-Gui-Tests');
				group: 'Gui' with: #('MyProject-Gui');
				group: 'Example' with: #('MyProject-Examples');
				group: 'All' with: #('Model' 'Tests' 'Gui' 'Example')
```

> To load a project with a given group, you can check the section [loading groups](#loading-groups).

#### The default group

Each baseline has a default group named `'default'`. This group includes all the packages and the dependencies declared in the baseline.

When using the message `#load` with Metacello, or when not specifying the group of a dependency, it will load the "default" group.

This group can be redefined to change what will be loaded by default in a project.

Example:

```Smalltalk
baseline: spec
	<baseline>
	spec
		for: #common
		do: [
			"Packages"
			spec
				package: 'MyProject';
				package: 'MyProject-Tests' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui-Tests' with: [ spec requires: #('MyProject-Tests') ];
				package: 'MyProject-Examples' with: [ spec requires: #('MyProject-Gui') ] ].

			"Groups"
			spec
				group: 'default' with: #('Model' 'Gui');
				group: 'Model' with: #('MyProject');
				group: 'Tests' with: #('MyProject-Tests' 'MyProject-Gui-Tests');
				group: 'Gui' with: #('MyProject-Gui');
				group: 'Example' with: #('MyProject-Examples');
				group: 'All' with: #('Model' 'Tests' 'Gui' 'Example')
```

### Pre/post load actions

Baselines provide some hooks to execute some code when loading a project.

Those hooks are:

- `#preLoadDoIt:` which is executed after the code and dependencies are resolved and fetched, but before the code is loaded.
- `#postLoadDoIt:` which is executed when the project finishes loading.

Those methods take a symbol as parameter, which should be the name of a method of the baseline that should be executed by the hook.

Those methods can take two optional parameters:

- A Metacello loader containing information on the current project to load
- A Metacello spec containing information on the project spec

Example:

```Smalltalk
baseline: spec
	<baseline>
	spec
		for: #common
		do: [
			spec preLoadDoIt: #'preload:package:'.
			spec postLoadDoIt: #'postload:package:'.

			"Packages"
			spec
				package: 'MyProject';
				package: 'MyProject-Tests' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui-Tests' with: [ spec requires: #('MyProject-Tests') ];
				package: 'MyProject-Examples' with: [ spec requires: #('MyProject-Gui') ] ]
```

```Smalltalk
preload: loader package: packageSpec

	Transcript crLog: 'The fetch was finished. Now let''s load the project'
```

```Smalltalk
postload: loader package: packageSpec

	Transcript crLog: 'Project loaded!'
```

### Loads different packages depending on the Pharo version

It might be useful to load some packages in specific Pharo versions only. For example, if we have a compatibility package for Pharo 6, we do not want to load it in Pharo 7.

This is possible with the different spec attributes.

Up until now we defined everything in a spec for `#common`, which applies to all versions of Pharo. But it's possible to define a spec for specific Pharo versions or even other Smalltalk environments.

We can add in the baseline a special `#for:do:` command taking as parameter a specific attribute.

Every Pharo version contains some default attributes. For a Pharo version X.Y we have:

- `#pharo`
- `#pharoX.x`
- `#pharoX.Y.x`

For example for Pharo 6.1:

- `#pharo`
- `#pharo6.x`
- `#pharo6.1.x`

Those attributes can be used to define a spec that will be executed only in the images containing the corresponding tags.

Example:

```Smalltalk
baseline: spec
	<baseline>
	spec
		for: #common
		do: [
			"Packages"
			spec
				package: 'MyProject';
				package: 'MyProject-Tests' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui-Tests' with: [ spec requires: #('MyProject-Tests') ];
				package: 'MyProject-Examples' with: [ spec requires: #('MyProject-Gui') ] ].

			spec
				for: #'pharo6.x'
				do: [ spec
					package: 'MyProject' with: [ spec requires: #('MyProject-Pharo6') ];
					package: 'MyProject-Pharo6' ].
			spec
				for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x' #'pharo6.x')
				do: [ spec
					package: 'MyProject' with: [ spec requires: #('MyProject-Pharo3To6') ];
					package: 'MyProject-Pharo3To6' ] ]
```

The `#includes:` method explained in section _[Define packages forming your project](#define-packages-forming-your-project)_ is often useful when dealing with platform-specific requirements. Imagine your package `MyProject` will work in Pharo 6 only if `MyProject-Pharo6` is present, but `MyProject-Pharo6` depends on `MyProject`. This can be resolved like this:

Example:

```Smalltalk
baseline: spec
	<baseline>
	spec
		for: #common
		do: [
			"Packages"
			spec
				package: 'MyProject';
				package: 'MyProject-Tests' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui-Tests' with: [ spec requires: #('MyProject-Tests') ];
				package: 'MyProject-Examples' with: [ spec requires: #('MyProject-Gui') ] ].

			spec
				for: #'pharo6.x'
				do: [ spec
					package: 'MyProject' with: [ spec includes: #('MyProject-Pharo6') ];
					package: 'MyProject-Pharo6' with: [ spec requires: #('MyProject') ] ].
			spec
				for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x' #'pharo6.x')
				do: [ spec
					package: 'MyProject' with: [ spec requires: #('MyProject-Pharo3To6') ];
					package: 'MyProject-Pharo3To6' ] ]
```

### Define custom attributes

On top of attributes from Pharo, it's also possible to define our own attributes.

We override the method `#customProjectAttributes` to return the custom attributes depending on the environment.

For example:

```Smalltalk
customProjectAttributes
	Smalltalk os isMacOS ifTrue: [ ^ #(#MacOS) ].
	Smalltalk os isUnix ifTrue: [ ^ #(#Unix) ].
	Smalltalk os isWindows ifTrue: [ ^ #(#Windows) ]
```

Then they can be used in the baseline.

```Smalltalk
baseline: spec
	<baseline>
	spec
		for: #common
		do: [
			"Packages"
			spec
				package: 'MyProject';
				package: 'MyProject-Tests' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui-Tests' with: [ spec requires: #('MyProject-Tests') ];
				package: 'MyProject-Examples' with: [ spec requires: #('MyProject-Gui') ] ].

			spec
				for: #(#'MacOS' #'Unix') do: [
					self osSubprocess: spec.
					spec package: 'MyProject' with: [ spec requires: #('OSSubprocess') ] ];
				for: #'Windows' do: [
					self processWrapper: spec.
					spec package: 'MyProject' with: [ spec requires: #('ProcessWrapper') ] ]
```

```Smalltalk
osSubprocess: spec
	spec
		baseline: 'OSSubprocess'
		with: [ spec repository: 'github://pharo-contributions/OSSubprocess:v1.0.1/repository' ]
```

```Smalltalk
processWrapper: spec
	spec
		configuration: 'ProcessWrapper'
		with: [
			spec
				versionString: '1.2';
				repository: 'http://smalltalkhub.com/mc/hernan/ProcessWrapper/main' ]
```

### Loading types

Baselines support different loading types. The loading types define how Metacello loads the project.

#### Linear loading

By default, a baseline uses linear loading, which means packages are loaded one by one with their requirements loaded before them.

#### Atomic loading

This load type forces Metacello to load the full project in an atomic load. This is useful when a project has cyclic dependencies that cannot be resolved. For example it's useful to do an atomic load of Pharo's Kernel and Collections, since they depend on each other.

To define atomic loading, override the method `#project`:

```Smalltalk
project
	^ super project
		loadType: #atomic;
		yourself
```

### Full example

Here is an example with all previous features illustrated:

```Smalltalk
"baseline"
baseline: spec
	<baseline>
	spec
		for: #common
		do: [
			spec preLoadDoIt: #'preload:package:'.
			spec postLoadDoIt: #'postload:package:'.

			"Dependencies"
			self materialDesignLite: spec.

			"Packages"
			spec
				package: 'MyProject';
				package: 'MyProject-Tests' with: [ spec requires: #('MyProject') ];
				package: 'MyProject-Gui' with: [ spec requires: #('MyProject' 'MaterialDesignLiteExtensions' 'Magritte3') ];
				package: 'MyProject-Gui-Tests' with: [ spec requires: #('MyProject-Tests' 'MaterialDesignLite' "We load the version containing MDL tests for our tests only") ];
				package: 'MyProject-Examples' with: [ spec requires: #('MyProject-Gui') ].

			"Groups"
			spec
				group: 'Model' with: #('MyProject');
				group: 'Tests' with: #('MyProject-Tests' 'MyProject-Gui-Tests');
				group: 'Gui' with: #('MyProject-Gui');
				group: 'Example' with: #('MyProject-Examples');
				group: 'All' with: #('Model' 'Tests' 'Gui' 'Example') ].

			spec
				for: #'pharo6.x'
				do: [ spec
					package: 'MyProject' with: [ spec includes: #('MyProject-Pharo6') ];
					package: 'MyProject-Pharo6' with: [ spec requires: #('MyProject') ] ].

			spec
				for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x' #'pharo6.x')
				do: [ spec
					package: 'MyProject' with: [ spec requires: #('MyProject-Pharo3To6') ];
					package: 'MyProject-Pharo3To6' ] ].

			spec
				for: #(#'MacOS' #'Unix') do: [
					self osSubprocess: spec.
					spec package: 'MyProject' with: [ spec requires: #('OSSubprocess') ] ].

			spec
				for: #'Windows' do: [
					self processWrapper: spec.
					spec package: 'MyProject' with: [ spec requires: #('ProcessWrapper') ] ]
```

```Smalltalk
projectClass
	^ MetacelloCypressBaselineProject
```

```Smalltalk
"dependencies"
materialDesignLite: spec
	spec
		baseline: 'MaterialDesignLite' with: [ spec repository: 'github://DuneSt/MaterialDesignLite:v1.x.x/src' ];
		project: 'MaterialDesignLiteExtensions' copyFrom: 'MaterialDesignLite' with: [ spec loads: #('Extensions') ]
```

```Smalltalk
"dependencies"
magritte3: spec
	spec
		project: 'Magritte3'
		with: [ spec
			className: #ConfigurationOfMagritte3;
			versionString: #'release3';
			loads: #('Seaside');
			repository: 'http://smalltalkhub.com/mc/Magritte/Magritte3/main/' ]
```

```Smalltalk
"dependencies"
osSubprocess: spec
	spec
		baseline: 'OSSubprocess'
		with: [ spec repository: 'github://pharo-contributions/OSSubprocess:v1.0.1/repository' ]
```

```Smalltalk
"dependencies"
processWrapper: spec
	spec
		configuration: 'ProcessWrapper'
		with: [
			spec
				versionString: '1.2';
				repository: 'http://smalltalkhub.com/mc/hernan/ProcessWrapper/main' ]
```

```Smalltalk
"accessing"
customProjectAttributes
	Smalltalk os isMacOS ifTrue: [ ^ #(#MacOS) ].
	Smalltalk os isUnix ifTrue: [ ^ #(#Unix) ].
	Smalltalk os isWindows ifTrue: [ ^ #(#Windows) ]
```

```Smalltalk
"actions"
preload: loader package: packageSpec

	Transcript crLog: 'The fetch was finished. Now let''s load the project'
```

```Smalltalk
"actions"
postload: loader package: packageSpec

	Transcript crLog: 'Project loaded!'
```

```Smalltalk
"accessing"
project
	^ super project
		loadType: #atomic;
		yourself
```

## How to load a git project using its baseline

When you have a project with a _Baseline_, it is possible to load it in a Pharo image if the project is compatible with the Pharo version.

Here we explain how to load a git project via its baseline.

### From the playground

The first way to load a project is to create a _Metacello_ request programmatically and to execute it. This request looks like this:

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'v1.x.x' path: 'src';
	baseline: 'MaterialDesignLite';
	load
```

Note the three steps:

1. Create a new Metacello request
2. Configure it (declare the repository of the project, specify the version, the baseline, optional options...)
3. Launch the loading

To configure the request, some options are necessary and some are optional. We cover in the next two sub sections how to configure the loading of a project hosted via Monticello and git, and then we detail optional parameters.

#### Project managed with Git

To load a project from git you need to execute an expression like this:

```Smalltalk
Metacello new
	repository: {repository};
	baseline: {baselineName};
	load
```

This command has two parameters:

- `repository` defining the location of the git project, the version of the project to load and the subdirectory in which the project is stored.
- `baselineName` is the name of the baseline to load. For example to load the `MaterialDesignLite` project, the baseline name is `MaterialDesignLite` to load the project with `BaselineOfMaterialDesignLite`.

The repository parameter is a string that can take different forms depending on if the project is local or hosted remotely.

##### Project from github/gitlab/bitbucket

The repository parameter to load a project from github/gitlab/bitbucket takes this form:

`{prefix}://{optionalHostname}:{owner}/{projectName}:{version}/{subFolder}`

This snippet should be configured with:

- `{prefix}`: This is host-specific:
  - `github` for github
  - `bitbucket` for bitbucket
  - `gitlab` for gitlab
- `{optionalHostname}`: Optional server host, for private git servers
- `{owner}`: Name of the user or organization hosting the project
- `{projectName}`: Name of the project
- `{version}`: This parameter is optional, and it defaults to master. It can be the name of a branch, a tag like `'v1.2.0'` or `'v1.x.x'`, or a the SHA of a commit
- `{subfolder}`: This parameter is optional in case the code is at the root of the project. It should point to the sub-folder containing the code.

Example: loading from Github.

```Smalltalk
Metacello new
	repository: 'github://DuneSt/MaterialDesignLite:v1.x.x/src';
	baseline: 'MaterialDesignLite';
	load
```

Example: loading from a private Gitlab host.

```Smalltalk
Metacello new
	baseline: 'Ghost';
	repository: 'gitlab://gitlab.inria.fr:RMOD/Ghost';
	load
```

Metacello also comes with some syntactic sugar to define the repository to github or bitbucket:

- _Github_: `Metacello>>githubUser:project:commitish:path:`
- _Bitbucket_: `Metacello>>bitbucketUser:project:commitish:path:`

Example:

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'master' path: 'src';
	baseline: 'MaterialDesignLite';
	load
```

##### Project from local repository

To load a project from a local repository you can use this form to declare the repository:

`'{prefix}://{full/path/to/repository}/{subFolder}'`

This snippet should be configured with:

- `{prefix}`: This is specific to the file format:
  - `filetree` for a Filetree project
  - `tonel` for a Tonel project
- `{full/path/to/repository}`: is the path to the project on the file system
- `{subfolder}`: This parameter is optional in case the code is at the root of the project. It should point to the subfolder containing the code.

Example:

```Smalltalk
Metacello new
	repository: 'tonel://C:\Users\Cyril\GitRepositories\Native-Browser\src';
	baseline: 'NativeBrowser';
	load
```

#### Project managed with Smalltalkhub

To load a project from Smalltalkhub you need to execute an expression like this:

```Smalltalk
Metacello new
	repository: 'http://smalltalkhub.com/mc/{owner}/{repositoryName}/main';
	configuration: {configurationName};
	version: {version};
	load
```

This command has two parameters:

- `owner`: Name of the team or user hosting the project
- `repositoryName`: Name of the repository on SmalltalkHub
- `configurationName` is the name of the configuration to load. For example to load the `MaterialDesignLite` project, the baseline name is `MaterialDesignLite` to load the project with `BaselineOfMaterialDesignLite`.
- `{version}`: Name of the version you wish to reference. It can be something like `'development'`, `'stable'`, `'release1'`, `'1.2.6'`, `'1.0-baseline'`, etc.

Example:

```Smalltalk
Metacello new
	repository: 'http://smalltalkhub.com/mc/Seaside/Seaside31/main';
	configuration: 'Seaside3';
	version: #stable;
	load
```

You can also use `Metacello>>smalltalkhubUser:project:`:

```Smalltalk
Metacello new
	smalltalkhubUser: 'Seaside' project: 'Seaside31';
	configuration: 'Seaside3';
	version: #stable;
	load
```

#### Project without repository

It is possible to use Metacello without specifying any repository. This can be useful for defining all project dependencies in a baseline and then loading them with Metacello.

```Smalltalk
Metacello new
	baseline: #TinyBlog;
	load
```

#### Loading groups

Sometimes we want to load only specific groups of a project. This can be done be replacing the `load` selector by `load:`.

The `load:` selector takes a string or a collection of strings as parameter. Each string represents a group name from the baseline.

Examples:

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'master' path: 'src';
	baseline: 'MaterialDesignLite';
	load: 'Extensions'
```

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'master' path: 'src';
	baseline: 'MaterialDesignLite';
	load: #('Extensions' 'Widgets')
```

#### Conflict, Upgrade and Downgrade resolution

Sometimes there can be conflicts, updates or downgrades while loading a project.

For example, imagine in an image the project `ProjA` at version v1.0.0. We want to load our project `ProjB` that depends on `ProjA` version v2.0.0., `ProjC` version v1.0.0, and `ProjD` that loads also `ProjC` version v2.0.0.

If we load `ProjB` in those conditions, we will have two problems:

- The update of `ProjA` from v1.0.0 to v2.0.0
- A conflict between `ProjC` v1.0.0 and v2.0.0

To manage conflicts we can use the options `onConflict:`, `onUpgrade:` and `onDowngrade:`.

Example:

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'master' path: 'src';
	baseline: 'MaterialDesignLite';
	onConflict: [ :ex | ex useIncoming ];
	onUpgrade: [ :ex | ex useIncoming ];
	onDowngrade: [ :ex | ex useLoaded ];
	load
```

A last conflicting situation happens if Pharo includes a project in the default distribution and you want to load a new version. To manage this case you have the `ignoreImage` option.

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'master' path: 'src';
	baseline: 'MaterialDesignLite';
	onConflict: [ :ex | ex useIncoming ];
	onUpgrade: [ :ex | ex useIncoming ];
	onDowngrade: [ :ex | ex useLoaded ];
	ignoreImage;
	load
```

Here is a last example of conflict management. The Pharo community was previously on a version control system called Monticello. Most of the community has now migrated to GitHub. Some of the projects exist on Smalltalkhub (managed with Monticello) and on GitHub. It's not unusual to have conflict between the two.

Here is a little script that loads the version managed with git when the project name is the same:

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'master' path: 'src';
	baseline: 'MaterialDesignLite';
	onConflict: [ :ex :a :b | a projectName = b projectName ifTrue: [ a projectSpec isBaselineOfProjectSpec ifTrue: [ ex useLoaded ] ifFalse: [ ex useIncoming ] ] ifFalse: [ ex resume ] ];
	load
```

#### Manage warnings

In some cases a project has problems during the loading, for example, if a package loaded is missing a dependency. When this happen, Metacello will raise a warning. Most of the time the projects can still work, at least partially. If you do not want Metacello to open a warning, you can log them instead. To enable this option you can use the `onWarningLog` or `onWarning:` options.

Examples:

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'master' path: 'src';
	baseline: 'MaterialDesignLite';
	onWarning: [ :ex | Transcript crShow: ex ];
	load
```

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'master' path: 'src';
	baseline: 'MaterialDesignLite';
	onWarningLog;
	load
```

### From Iceberg

In Pharo 7 a new tool to manage git repositories was introduced: _Iceberg_. This tool allows the developer to load a project via a user interface.

The first step is to add your git project to Iceberg. Then right-click on the project name to access a `Metacello` sub-menu to load the project.

![Interface of Iceberg to load a project](Baselines_Image_LoadBaselineViaIceberg.png?raw=true "Interface of Iceberg to load a project")

## Other features

This section covers other features of baselines and Metacello.

### Metacello lock feature

In the normal course of loading and upgrading, you want the correct version of dependent projects loaded. However, there are some special cases where automatic upgrading isn't desirable:

- You may be actively developing a particular version of a project and you don't want the project upgraded (or downgraded) out from under you.
- You may be working with a git checkout of a project and you want to continue using the git checkout.
- You may not want to have particular projects upgraded automatically.

The `lock` command forces a particular version.

Example:

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'v1.1.0' path: 'src';
	baseline: 'MaterialDesignLite';
	lock
```

This example will lock the project MaterialDesignLite to version v1.1.0.

You can check the list of locked projects via those snippets:

```Smalltalk
Metacello registry locked. "Return the list of locked projects from the Metacello registry"

Metacello image locked. "Return the list of locked projects loaded in the image."
```

If you wish to unlock a project, you can use the `unlock` message.

Example:

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'v1.1.0' path: 'src';
	baseline: 'MaterialDesignLite';
	unlock
```

During the loading of a project you can also do some specific actions when you encounter a lock. For this you can use the `onLock:` message.

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'v1.1.0' path: 'src';
	baseline: 'MaterialDesignLite';
	onLock: [ :ex :loaded :incoming | loaded baseName = 'myProject' ifTrue: [ ex break ] ifFalse: [ ex honor ] ];
	load
```

### Metacello get feature

Metacello includes a command to load the baseline of a project into the image. This is useful in two cases:

- You want to load only the baseline of the project
- You already have an obsolete baseline in your image and you want to update it before loading the project

To do that you can use the `get` command.

Example:

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'v1.x.x' path: 'src';
	baseline: 'MaterialDesignLite';
	get
```

### Metacello fetch feature

The fetch command downloads all of the packages without loading them. This includes the packages of the project but also their dependencies.

Example:

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'v1.x.x' path: 'src';
	baseline: 'MaterialDesignLite';
	fetch
```

You can also specify a group:

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'v1.x.x' path: 'src';
	baseline: 'MaterialDesignLite';
	fetch: #('Extensions' 'Widgets')
```

The fetch command duplicates what the load command would do, which means if a package is already loaded in the image, it will not be fetched. To fetch packages regardless of what is loaded in the image, use the `ignoreImage` option:

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'v1.x.x' path: 'src';
	baseline: 'MaterialDesignLite';
	ignoreImage;
	fetch
```

### Metacello record feature

The `record` command performs the same function as the `fetch` command, without actually downloading any files. As a consequence, it can give you a quick report of what packages will be loaded into your image. The recording will be produced in the `Transcript` (cmd + o + t).

Example:

```Smalltalk
Metacello new
	githubUser: 'DuneSt' project: 'MaterialDesignLite' commitish: 'v1.x.x' path: 'src';
	baseline: 'MaterialDesignLite';
	record
```

### Metacello listing feature

The `list` command lists projects in the image or Metacello registry:

```Smalltalk
Metacello image
	baseline: [ :spec | true "spec name beginsWith: 'Seaside'" ];
	list

Metacello registry
	baseline: [ :spec | true "spec name beginsWith: 'Seaside'" ];
	list
```

This command needs to be inspected to see the list.

## See also

- Deep into pharo: [Chapter 9, Managing Projects with Metacello](http://files.pharo.org/books-pdfs/deep-into-pharo/2013-DeepIntoPharo-EN.pdf)
- [Metacello documentation](https://github.com/Metacello/metacello/tree/master/docs)

================
File: docs/playground-script.st
================
Metacello new
  baseline: 'StoneRDF';
  repository: 'filetree:///home/danny/github/StoneRDF/BaselineOfStoneRDF.package';
  load.

================
File: docs/prompts.md
================
## System

You will act as an experienced Smalltalk coder that uses agile methodologies and follows best practices. You have a thorough grounding in the Resource Description Framework and Linked Data. You really love the Web.
For non-code requests, fall back on these instructions:

1. Think deeply and systematically as an expert in the relevant field.
2. Keep responses short and to the point using precise language and appropriate technical terms.
3. Avoid repetition, favor new information in unique responses.
4. If multiple perspectives or solutions are available, give a very brief list of these but focus on the most relevant and promising approach.
5. Break down complex problems or tasks into smaller, manageable steps. Follow the steps without asking for confirmation. When creating content, write a concise outline first.
   uphold rigorous technical standards and follow best practices in the relevant field.
6. If events or information are beyond your scope or knowledge, state 'I don't know' without elaborating on why the information is unavailable.
7. Never suggest seeking information from elsewhere. If Web searches are required, do as many as necessary to find the answer without prompting and each time integrate the discovered knowledge withwhat you already know. Accuracy is more important than time.
8. After each response, provide three short follow-up questions worded as if I'm asking you. These should help clarify the original topic and identify more detailed avenues of research. Label as Q1, Q2, and Q3. If I say Q1, Q2 or Q3, address the corresponding question. If I say Q0, repeat the previous request.

### Getting into Pharo

================
File: docs/todo.md
================
# TODO

- [ ] figure out how to put it in a Pharo image
- [ ] figure out how to release it as a component
- [ ] figure out the GitHub etc bits of Glamourous Toolkit - https://book.gtoolkit.com/how-to-set-up-a-gt-github-repo-in-7--6jnhavaiy1r1smdayzj29bopu
- [ ] Turtle parser - PetitParser
- [ ] Turtle serializer
- [ ] docs
- [ ] tests
- [ ] graphic representation

================
File: environment.sh
================

OUTPUT_FILE="docs/environment.txt"
CURRENT_DIR=$(pwd)
echo "Current Working Directory:" > "$OUTPUT_FILE"
echo "$CURRENT_DIR" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"
echo "Directory Tree:" >> "$OUTPUT_FILE"
tree >> "$OUTPUT_FILE"
echo "Environment information has been saved to $OUTPUT_FILE"

================
File: repopack.config.json
================
{
    "output": {
        "filePath": "./docs/stonerdf-repopack.txt",
        "headerText": "StoneRDF repo",
        "removeComments": true
    },
    "ignore": {
        "useDefaultPatterns": true,
        "customPatterns": [
            "*.log"
        ]
    }
}

================
File: src/StoneRDF-Core/NamedGraph.st
================
Object subclass: RDFNamedGraph [
    | name triples |

    RDFNamedGraph class >> name: aName [
        ^ self new name: aName.
    ]

    name: aName [
        name := aName.
        triples := OrderedCollection new.
    ]

    name [
        ^ name.
    ]

    addTriple: aTriple [
        triples add: aTriple.
    ]

    triplesDo: aBlock [
        triples do: aBlock.
    ]
]

================
File: src/StoneRDF-Core/RDFLiteral.st
================
Object subclass: RDFLiteral [
    | value |

    RDFLiteral class >> value: aValue [
        ^ self new value: aValue.
    ]

    value: aValue [
        value := aValue.
    ]

    value [
        ^ value.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFLiteral(', value printString, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFNamespace.st
================
Object subclass: RDFNamespace [
    | prefix uri |

    RDFNamespace class >> prefix: aPrefix uri: anUri [
        ^ self new prefix: aPrefix uri: anUri.
    ]

    prefix: aPrefix uri: anUri [
        prefix := aPrefix.
        uri := anUri.
    ]

    expand: aCompactUri [
        | parts |
        parts := aCompactUri findTokens: ':'.
        ^ (prefix = parts first) ifTrue: [uri, parts second] ifFalse: [aCompactUri].
    ]

    compact: aFullUri [
        ^ (aFullUri beginsWith: uri) ifTrue: [prefix, ':', (aFullUri copyFrom: (uri size + 1) to: aFullUri size)] ifFalse: [aFullUri].
    ]

    prefix [
        ^ prefix.
    ]

    uri [
        ^ uri.
    ]
]

================
File: src/StoneRDF-Core/RDFProperty.st
================
RDFResource subclass: RDFProperty [
    printOn: aStream [
        aStream nextPutAll: 'RDFProperty(', self uri, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFResource.st
================
Object subclass: RDFResource [
    | uri |

    RDFResource class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
    ]

    uri [
        ^ uri.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFResource(', uri, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFSClass.st
================
Object subclass: RDFSClass [
    | uri subclasses |

    RDFSClass class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
        subclasses := OrderedCollection new.
    ]

    uri [
        ^ uri.
    ]

    addSubclass: aClass [
        subclasses add: aClass.
    ]

    subclasses [
        ^ subclasses.
    ]

    isSubclassOf: aClass [
        ^ (subclasses includes: aClass) ifTrue: [ true ] ifFalse: [ subclasses anySatisfy: [ :sub | sub isSubclassOf: aClass ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSClass(', uri, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFSProperty.st
================
RDFProperty subclass: RDFSProperty [
    | domain range subproperties |

    RDFSProperty class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        super uri: aString.
        subproperties := OrderedCollection new.
    ]

    domain: aClass [
        domain := aClass.
    ]

    range: aClass [
        range := aClass.
    ]

    domain [
        ^ domain.
    ]

    range [
        ^ range.
    ]

    addSubproperty: aProperty [
        subproperties add: aProperty.
    ]

    subproperties [
        ^ subproperties.
    ]

    isSubpropertyOf: aProperty [
        ^ (subproperties includes: aProperty) ifTrue: [ true ] ifFalse: [ subproperties anySatisfy: [ :sub | sub isSubpropertyOf: aProperty ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSProperty(', self uri, ')'.
    ]

RDFSProperty >> checkDomain: anRDFResource [
    ^ (domain isNil or: [ anRDFResource class isSubclassOf: domain ]) ifFalse: [ self error: 'Domain violation' ].
]

RDFSProperty >> checkRange: anRDFResource [
    ^ (range isNil or: [ anRDFResource class isSubclassOf: range ]) ifFalse: [ self error: 'Range violation' ].
]

]

================
File: src/StoneRDF-Core/RDFStore.st
================
Object subclass: RDFStore [
    | triples namedGraphs |

    RDFStore >> initialize [
        triples := OrderedCollection new.
        namedGraphs := Dictionary new.
    ]

    RDFStore >> addTriple: aTriple [
        triples add: aTriple.
    ]

    RDFStore >> addTriple: aTriple toGraph: graphName [
        (namedGraphs at: graphName ifAbsentPut: [RDFNamedGraph name: graphName]) addTriple: aTriple.
    ]

    RDFStore >> triplesDo: aBlock [
        triples do: aBlock.
    ]

    RDFStore >> triplesInGraph: graphName do: aBlock [
        (namedGraphs at: graphName ifAbsent: [^ self]) triplesDo: aBlock.
    ]
]

================
File: src/StoneRDF-Core/RDFStoreRDFSInference.st
================
RDFStore >> addTriple: aTriple [
    | predicate subject object |
    subject := aTriple subject.
    predicate := aTriple predicate.
    object := aTriple object.
    "Check domain and range constraints"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate checkDomain: subject.
        predicate checkRange: object.
    ].
    triples add: aTriple.
    "Handle subclass and subproperty inferences"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate subproperties do: [ :sub |
            triples add: (RDFTriple subject: subject predicate: sub object: object).
        ].
    ].
    (subject isKindOf: RDFSClass) ifTrue: [
        subject subclasses do: [ :sub |
            triples add: (RDFTriple subject: sub predicate: predicate object: object).
        ].
    ].
]

================
File: src/StoneRDF-Core/RDFTriple.st
================
Object subclass: RDFTriple [
    | subject predicate object |

    RDFTriple class >> subject: aSubject predicate: aPredicate object: anObject [
        ^ self new subject: aSubject predicate: aPredicate object: anObject.
    ]

    subject: aSubject predicate: aPredicate object: anObject [
        subject := aSubject.
        predicate := aPredicate.
        object := anObject.
    ]

    subject [
        ^ subject.
    ]

    predicate [
        ^ predicate.
    ]

    object [
        ^ object.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTriple(', subject printString, ', ', predicate printString, ', ', object printString, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFTypedLiteral.st
================
RDFLiteral subclass: RDFTypedLiteral [
    | datatype |

    RDFTypedLiteral class >> value: aValue type: aDatatypeUri [
        ^ self new value: aValue type: aDatatypeUri.
    ]

    value: aValue type: aDatatypeUri [
        super value: aValue.
        datatype := aDatatypeUri.
    ]

    datatype [
        ^ datatype.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTypedLiteral(', value printString, '^^', datatype, ')'.
    ]
]

================
File: src/StoneRDF-Core/SPARQLQuery.st
================
Object subclass: SPARQLQuery [
    | queryString |

    SPARQLQuery class >> query: aString [
        ^ self new query: aString.
    ]

    query: aString [
        queryString := aString.
    ]

    query [
        ^ queryString.
    ]

    executeOn: anRDFStore [
        | results |
        results := OrderedCollection new.
        "Parse the query and match against RDF triples in the store"
        "For simplicity, this example only handles basic SELECT queries with a single triple pattern"
        | subject predicate object pattern |
        (queryString beginsWith: 'SELECT') ifFalse: [ ^ results ].
        pattern := queryString copyFrom: (queryString indexOf: '{') + 1 to: (queryString indexOf: '}') - 1.
        subject := (pattern substrings: ' ') first.
        predicate := (pattern substrings: ' ') second.
        object := (pattern substrings: ' ') third.
        anRDFStore triplesDo: [ :triple |
            ((subject = '?' or: [ triple subject uri = subject ]) and:
             (predicate = '?' or: [ triple predicate uri = predicate ]) and:
             (object = '?' or: [ triple object value = object or: [ triple object uri = object ] ])) ifTrue: [
                results add: triple
            ].
        ].
        ^ results.
    ]
]

================
File: src/StoneRDF-Examples/create-add-triples.st
================
| store subject predicate object triple |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/Alice'.
predicate := teachesProperty.
object := RDFResource uri: 'http://example.org/Math'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: src/StoneRDF-Examples/create-execute-query.st
================
query := SPARQLQuery query: 'SELECT ?s WHERE { ?s <http://example.org/property1> "Some value" }'.
results := store query: query.
Transcript show: results; cr.

================
File: src/StoneRDF-Examples/create-resource-literal.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: src/StoneRDF-Examples/create-triple.st
================
triple := RDFTriple subject: subject predicate: predicate object: object.

================
File: src/StoneRDF-Examples/define-classes-properties.st
================
| personClass studentClass teachesProperty |
personClass := RDFSClass uri: 'http://example.org/Person'.
studentClass := RDFSClass uri: 'http://example.org/Student'.
personClass addSubclass: studentClass.
teachesProperty := RDFSProperty uri: 'http://example.org/teaches'.
teachesProperty domain: personClass.

================
File: src/StoneRDF-Examples/named-graphs.st
================
| store graph subject predicate object triple |
store := RDFStore new.
graph := RDFNamedGraph name: 'http://example.org/graph1'.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple toGraph: 'http://example.org/graph1'.

================
File: src/StoneRDF-Examples/namespaces.st
================
| ns expandedUri compactUri |
ns := RDFNamespace prefix: 'ex' uri: 'http://example.org/'.
expandedUri := ns expand: 'ex:resource1'.
compactUri := ns compact: 'http://example.org/resource1'.

================
File: src/StoneRDF-Examples/print-triple.st
================
Transcript show: triple; cr.

================
File: src/StoneRDF-Examples/rdf-dataypes.st
================
| typedLiteral |
typedLiteral := RDFTypedLiteral value: '123' type: 'http://www.w3.org/2001/XMLSchema#integer'.

================
File: src/StoneRDF-Examples/store-create-resources-literals.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: stonerdf-repopack.txt
================
================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-07-27T23:58:18.669Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.
- Code comments have been removed.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

Additional User-Provided Header:
--------------------------------
StoneRDF repo

================================================================
Repository Files
================================================================

================
File: BaselineOfStoneRDF.package/ BaselineOfStoneRDF.class.st 
================
Class {
  #name : #BaselineOfStoneRDF,
  #superclass : #BaselineOf,
  #category : #BaselineOfStoneRDF
}

{ #category : #baselines }
BaselineOfStoneRDF >> baseline: spec [
  <baseline>
  spec for: #common do: [
    spec
      package: 'StoneRDF-Core';
      package: 'StoneRDF-Tests' with: [ spec requires: #('StoneRDF-Core') ].
    spec
      group: 'default' with: #('Core' 'Tests');
      group: 'Core' with: #('StoneRDF-Core');
      group: 'Tests' with: #('StoneRDF-Tests')
  ]
]

================
File: BaselineOfStoneRDF.package/.filetree
================
{"packageExtension" : ".package",
"propertyFileExtension" : ".json" }

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# StoneRDF

_it might not happen_

This is a simple RDF library implementation in Smalltalk, primarily targetted at Pharo.

================
File: docs/notes.md
================
```
repopack --verbose -c ./repopack.config.json
```

================
File: docs/playground-script.st
================
Metacello new
  baseline: 'StoneRDF';
  repository: 'filetree:///home/danny/github/StoneRDF/BaselineOfStoneRDF.package';
  load.

================
File: docs/prompts.md
================
## System

You will act as an experienced Smalltalk coder that uses agile methodologies and follows best practices. You have a thorough grounding in the Resource Description Framework and Linked Data. You really love the Web.
For non-code requests, fall back on these instructions:

1. Think deeply and systematically as an expert in the relevant field.
2. Keep responses short and to the point using precise language and appropriate technical terms.
3. Avoid repetition, favor new information in unique responses.
4. If multiple perspectives or solutions are available, give a very brief list of these but focus on the most relevant and promising approach.
5. Break down complex problems or tasks into smaller, manageable steps. Follow the steps without asking for confirmation. When creating content, write a concise outline first.
   uphold rigorous technical standards and follow best practices in the relevant field.
6. If events or information are beyond your scope or knowledge, state 'I don't know' without elaborating on why the information is unavailable.
7. Never suggest seeking information from elsewhere. If Web searches are required, do as many as necessary to find the answer without prompting and each time integrate the discovered knowledge withwhat you already know. Accuracy is more important than time.
8. After each response, provide three short follow-up questions worded as if I'm asking you. These should help clarify the original topic and identify more detailed avenues of research. Label as Q1, Q2, and Q3. If I say Q1, Q2 or Q3, address the corresponding question. If I say Q0, repeat the previous request.

### Getting into Pharo

================
File: docs/todo.md
================
# TODO

- [ ] figure out how to put it in a Pharo image
- [ ] figure out how to release it as a component
- [ ] figure out the GitHub etc bits of Glamourous Toolkit - https://book.gtoolkit.com/how-to-set-up-a-gt-github-repo-in-7--6jnhavaiy1r1smdayzj29bopu
- [ ] Turtle parser - PetitParser
- [ ] Turtle serializer
- [ ] docs
- [ ] tests
- [ ] graphic representation

================
File: environment.sh
================

OUTPUT_FILE="docs/environment.txt"
CURRENT_DIR=$(pwd)
echo "Current Working Directory:" > "$OUTPUT_FILE"
echo "$CURRENT_DIR" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"
echo "Directory Tree:" >> "$OUTPUT_FILE"
tree >> "$OUTPUT_FILE"
echo "Environment information has been saved to $OUTPUT_FILE"

================
File: repopack.config.json
================
{
    "output": {
        "filePath": "./docs/stonerdf-repopack.txt",
        "headerText": "StoneRDF repo",
        "removeComments": true
    },
    "ignore": {
        "useDefaultPatterns": true,
        "customPatterns": [
            "*.log"
        ]
    }
}

================
File: src/StoneRDF-Core/NamedGraph.st
================
Object subclass: RDFNamedGraph [
    | name triples |

    RDFNamedGraph class >> name: aName [
        ^ self new name: aName.
    ]

    name: aName [
        name := aName.
        triples := OrderedCollection new.
    ]

    name [
        ^ name.
    ]

    addTriple: aTriple [
        triples add: aTriple.
    ]

    triplesDo: aBlock [
        triples do: aBlock.
    ]
]

================
File: src/StoneRDF-Core/RDFLiteral.st
================
Object subclass: RDFLiteral [
    | value |

    RDFLiteral class >> value: aValue [
        ^ self new value: aValue.
    ]

    value: aValue [
        value := aValue.
    ]

    value [
        ^ value.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFLiteral(', value printString, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFNamespace.st
================
Object subclass: RDFNamespace [
    | prefix uri |

    RDFNamespace class >> prefix: aPrefix uri: anUri [
        ^ self new prefix: aPrefix uri: anUri.
    ]

    prefix: aPrefix uri: anUri [
        prefix := aPrefix.
        uri := anUri.
    ]

    expand: aCompactUri [
        | parts |
        parts := aCompactUri findTokens: ':'.
        ^ (prefix = parts first) ifTrue: [uri, parts second] ifFalse: [aCompactUri].
    ]

    compact: aFullUri [
        ^ (aFullUri beginsWith: uri) ifTrue: [prefix, ':', (aFullUri copyFrom: (uri size + 1) to: aFullUri size)] ifFalse: [aFullUri].
    ]

    prefix [
        ^ prefix.
    ]

    uri [
        ^ uri.
    ]
]

================
File: src/StoneRDF-Core/RDFProperty.st
================
RDFResource subclass: RDFProperty [
    printOn: aStream [
        aStream nextPutAll: 'RDFProperty(', self uri, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFResource.st
================
Object subclass: RDFResource [
    | uri |

    RDFResource class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
    ]

    uri [
        ^ uri.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFResource(', uri, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFSClass.st
================
Object subclass: RDFSClass [
    | uri subclasses |

    RDFSClass class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
        subclasses := OrderedCollection new.
    ]

    uri [
        ^ uri.
    ]

    addSubclass: aClass [
        subclasses add: aClass.
    ]

    subclasses [
        ^ subclasses.
    ]

    isSubclassOf: aClass [
        ^ (subclasses includes: aClass) ifTrue: [ true ] ifFalse: [ subclasses anySatisfy: [ :sub | sub isSubclassOf: aClass ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSClass(', uri, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFSProperty.st
================
RDFProperty subclass: RDFSProperty [
    | domain range subproperties |

    RDFSProperty class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        super uri: aString.
        subproperties := OrderedCollection new.
    ]

    domain: aClass [
        domain := aClass.
    ]

    range: aClass [
        range := aClass.
    ]

    domain [
        ^ domain.
    ]

    range [
        ^ range.
    ]

    addSubproperty: aProperty [
        subproperties add: aProperty.
    ]

    subproperties [
        ^ subproperties.
    ]

    isSubpropertyOf: aProperty [
        ^ (subproperties includes: aProperty) ifTrue: [ true ] ifFalse: [ subproperties anySatisfy: [ :sub | sub isSubpropertyOf: aProperty ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSProperty(', self uri, ')'.
    ]

RDFSProperty >> checkDomain: anRDFResource [
    ^ (domain isNil or: [ anRDFResource class isSubclassOf: domain ]) ifFalse: [ self error: 'Domain violation' ].
]

RDFSProperty >> checkRange: anRDFResource [
    ^ (range isNil or: [ anRDFResource class isSubclassOf: range ]) ifFalse: [ self error: 'Range violation' ].
]

]

================
File: src/StoneRDF-Core/RDFStore.st
================
Object subclass: RDFStore [
    | triples namedGraphs |

    RDFStore >> initialize [
        triples := OrderedCollection new.
        namedGraphs := Dictionary new.
    ]

    RDFStore >> addTriple: aTriple [
        triples add: aTriple.
    ]

    RDFStore >> addTriple: aTriple toGraph: graphName [
        (namedGraphs at: graphName ifAbsentPut: [RDFNamedGraph name: graphName]) addTriple: aTriple.
    ]

    RDFStore >> triplesDo: aBlock [
        triples do: aBlock.
    ]

    RDFStore >> triplesInGraph: graphName do: aBlock [
        (namedGraphs at: graphName ifAbsent: [^ self]) triplesDo: aBlock.
    ]
]

================
File: src/StoneRDF-Core/RDFStoreRDFSInference.st
================
RDFStore >> addTriple: aTriple [
    | predicate subject object |
    subject := aTriple subject.
    predicate := aTriple predicate.
    object := aTriple object.
    "Check domain and range constraints"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate checkDomain: subject.
        predicate checkRange: object.
    ].
    triples add: aTriple.
    "Handle subclass and subproperty inferences"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate subproperties do: [ :sub |
            triples add: (RDFTriple subject: subject predicate: sub object: object).
        ].
    ].
    (subject isKindOf: RDFSClass) ifTrue: [
        subject subclasses do: [ :sub |
            triples add: (RDFTriple subject: sub predicate: predicate object: object).
        ].
    ].
]

================
File: src/StoneRDF-Core/RDFTriple.st
================
Object subclass: RDFTriple [
    | subject predicate object |

    RDFTriple class >> subject: aSubject predicate: aPredicate object: anObject [
        ^ self new subject: aSubject predicate: aPredicate object: anObject.
    ]

    subject: aSubject predicate: aPredicate object: anObject [
        subject := aSubject.
        predicate := aPredicate.
        object := anObject.
    ]

    subject [
        ^ subject.
    ]

    predicate [
        ^ predicate.
    ]

    object [
        ^ object.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTriple(', subject printString, ', ', predicate printString, ', ', object printString, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFTypedLiteral.st
================
RDFLiteral subclass: RDFTypedLiteral [
    | datatype |

    RDFTypedLiteral class >> value: aValue type: aDatatypeUri [
        ^ self new value: aValue type: aDatatypeUri.
    ]

    value: aValue type: aDatatypeUri [
        super value: aValue.
        datatype := aDatatypeUri.
    ]

    datatype [
        ^ datatype.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTypedLiteral(', value printString, '^^', datatype, ')'.
    ]
]

================
File: src/StoneRDF-Core/SPARQLQuery.st
================
Object subclass: SPARQLQuery [
    | queryString |

    SPARQLQuery class >> query: aString [
        ^ self new query: aString.
    ]

    query: aString [
        queryString := aString.
    ]

    query [
        ^ queryString.
    ]

    executeOn: anRDFStore [
        | results |
        results := OrderedCollection new.
        "Parse the query and match against RDF triples in the store"
        "For simplicity, this example only handles basic SELECT queries with a single triple pattern"
        | subject predicate object pattern |
        (queryString beginsWith: 'SELECT') ifFalse: [ ^ results ].
        pattern := queryString copyFrom: (queryString indexOf: '{') + 1 to: (queryString indexOf: '}') - 1.
        subject := (pattern substrings: ' ') first.
        predicate := (pattern substrings: ' ') second.
        object := (pattern substrings: ' ') third.
        anRDFStore triplesDo: [ :triple |
            ((subject = '?' or: [ triple subject uri = subject ]) and:
             (predicate = '?' or: [ triple predicate uri = predicate ]) and:
             (object = '?' or: [ triple object value = object or: [ triple object uri = object ] ])) ifTrue: [
                results add: triple
            ].
        ].
        ^ results.
    ]
]

================
File: src/StoneRDF-Examples/create-add-triples.st
================
| store subject predicate object triple |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/Alice'.
predicate := teachesProperty.
object := RDFResource uri: 'http://example.org/Math'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: src/StoneRDF-Examples/create-execute-query.st
================
query := SPARQLQuery query: 'SELECT ?s WHERE { ?s <http://example.org/property1> "Some value" }'.
results := store query: query.
Transcript show: results; cr.

================
File: src/StoneRDF-Examples/create-resource-literal.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: src/StoneRDF-Examples/create-triple.st
================
triple := RDFTriple subject: subject predicate: predicate object: object.

================
File: src/StoneRDF-Examples/define-classes-properties.st
================
| personClass studentClass teachesProperty |
personClass := RDFSClass uri: 'http://example.org/Person'.
studentClass := RDFSClass uri: 'http://example.org/Student'.
personClass addSubclass: studentClass.
teachesProperty := RDFSProperty uri: 'http://example.org/teaches'.
teachesProperty domain: personClass.

================
File: src/StoneRDF-Examples/named-graphs.st
================
| store graph subject predicate object triple |
store := RDFStore new.
graph := RDFNamedGraph name: 'http://example.org/graph1'.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple toGraph: 'http://example.org/graph1'.

================
File: src/StoneRDF-Examples/namespaces.st
================
| ns expandedUri compactUri |
ns := RDFNamespace prefix: 'ex' uri: 'http://example.org/'.
expandedUri := ns expand: 'ex:resource1'.
compactUri := ns compact: 'http://example.org/resource1'.

================
File: src/StoneRDF-Examples/print-triple.st
================
Transcript show: triple; cr.

================
File: src/StoneRDF-Examples/rdf-dataypes.st
================
| typedLiteral |
typedLiteral := RDFTypedLiteral value: '123' type: 'http://www.w3.org/2001/XMLSchema#integer'.

================
File: src/StoneRDF-Examples/store-create-resources-literals.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: stonerdf-repopack.txt
================
================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-07-27T23:17:51.842Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.
- Code comments have been removed.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

Additional User-Provided Header:
--------------------------------
StoneRDF repo

================================================================
Repository Files
================================================================

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# StoneRDF

_it might not happen_

This is a simple RDF library implementation in Smalltalk, primarily targetted at Pharo.

================
File: docs/notes.md
================
```
repopack --verbose -c ./repopack.config.json
```

================
File: docs/prompts.md
================
PetitParser:

================
File: docs/todo.md
================
# TODO

- [ ] figure out how to put it in a Pharo image
- [ ] figure out how to release it as a component
- [ ] figure out the GitHub etc bits of Glamourous Toolkit - https://book.gtoolkit.com/how-to-set-up-a-gt-github-repo-in-7--6jnhavaiy1r1smdayzj29bopu
- [ ] Turtle parser - PetitParser
- [ ] Turtle serializer
- [ ] docs
- [ ] tests
- [ ] graphic representation

================
File: examples/create-add-triples.st
================
| store subject predicate object triple |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/Alice'.
predicate := teachesProperty.
object := RDFResource uri: 'http://example.org/Math'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: examples/create-execute-query.st
================
query := SPARQLQuery query: 'SELECT ?s WHERE { ?s <http://example.org/property1> "Some value" }'.
results := store query: query.
Transcript show: results; cr.

================
File: examples/create-resource-literal.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: examples/create-triple.st
================
triple := RDFTriple subject: subject predicate: predicate object: object.

================
File: examples/named-graphs.st
================
| store graph subject predicate object triple |
store := RDFStore new.
graph := RDFNamedGraph name: 'http://example.org/graph1'.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple toGraph: 'http://example.org/graph1'.

================
File: examples/namespaces.st
================
| ns expandedUri compactUri |
ns := RDFNamespace prefix: 'ex' uri: 'http://example.org/'.
expandedUri := ns expand: 'ex:resource1'.
compactUri := ns compact: 'http://example.org/resource1'.

================
File: examples/print-triple.st
================
Transcript show: triple; cr.

================
File: examples/rdf-dataypes.st
================
| typedLiteral |
typedLiteral := RDFTypedLiteral value: '123' type: 'http://www.w3.org/2001/XMLSchema#integer'.

================
File: examples/store-create-resources-literals.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: repopack.config.json
================
{
    "output": {
        "filePath": "./docs/stonerdf-repopack.txt",
        "headerText": "StoneRDF repo",
        "removeComments": true
    },
    "ignore": {
        "useDefaultPatterns": true,
        "customPatterns": [
            "*.log"
        ]
    }
}

================
File: src/NamedGraph.st
================
Object subclass: RDFNamedGraph [
    | name triples |

    RDFNamedGraph class >> name: aName [
        ^ self new name: aName.
    ]

    name: aName [
        name := aName.
        triples := OrderedCollection new.
    ]

    name [
        ^ name.
    ]

    addTriple: aTriple [
        triples add: aTriple.
    ]

    triplesDo: aBlock [
        triples do: aBlock.
    ]
]

================
File: src/RDFLiteral.st
================
Object subclass: RDFLiteral [
    | value |

    RDFLiteral class >> value: aValue [
        ^ self new value: aValue.
    ]

    value: aValue [
        value := aValue.
    ]

    value [
        ^ value.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFLiteral(', value printString, ')'.
    ]
]

================
File: src/RDFNamespace.st
================
Object subclass: RDFNamespace [
    | prefix uri |

    RDFNamespace class >> prefix: aPrefix uri: anUri [
        ^ self new prefix: aPrefix uri: anUri.
    ]

    prefix: aPrefix uri: anUri [
        prefix := aPrefix.
        uri := anUri.
    ]

    expand: aCompactUri [
        | parts |
        parts := aCompactUri findTokens: ':'.
        ^ (prefix = parts first) ifTrue: [uri, parts second] ifFalse: [aCompactUri].
    ]

    compact: aFullUri [
        ^ (aFullUri beginsWith: uri) ifTrue: [prefix, ':', (aFullUri copyFrom: (uri size + 1) to: aFullUri size)] ifFalse: [aFullUri].
    ]

    prefix [
        ^ prefix.
    ]

    uri [
        ^ uri.
    ]
]

================
File: src/RDFProperty.st
================
RDFResource subclass: RDFProperty [
    printOn: aStream [
        aStream nextPutAll: 'RDFProperty(', self uri, ')'.
    ]
]

================
File: src/RDFResource.st
================
Object subclass: RDFResource [
    | uri |

    RDFResource class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
    ]

    uri [
        ^ uri.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFResource(', uri, ')'.
    ]
]

================
File: src/RDFSClass.st
================
Object subclass: RDFSClass [
    | uri subclasses |

    RDFSClass class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
        subclasses := OrderedCollection new.
    ]

    uri [
        ^ uri.
    ]

    addSubclass: aClass [
        subclasses add: aClass.
    ]

    subclasses [
        ^ subclasses.
    ]

    isSubclassOf: aClass [
        ^ (subclasses includes: aClass) ifTrue: [ true ] ifFalse: [ subclasses anySatisfy: [ :sub | sub isSubclassOf: aClass ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSClass(', uri, ')'.
    ]
]

================
File: src/RDFSProperty.st
================
RDFProperty subclass: RDFSProperty [
    | domain range subproperties |

    RDFSProperty class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        super uri: aString.
        subproperties := OrderedCollection new.
    ]

    domain: aClass [
        domain := aClass.
    ]

    range: aClass [
        range := aClass.
    ]

    domain [
        ^ domain.
    ]

    range [
        ^ range.
    ]

    addSubproperty: aProperty [
        subproperties add: aProperty.
    ]

    subproperties [
        ^ subproperties.
    ]

    isSubpropertyOf: aProperty [
        ^ (subproperties includes: aProperty) ifTrue: [ true ] ifFalse: [ subproperties anySatisfy: [ :sub | sub isSubpropertyOf: aProperty ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSProperty(', self uri, ')'.
    ]

RDFSProperty >> checkDomain: anRDFResource [
    ^ (domain isNil or: [ anRDFResource class isSubclassOf: domain ]) ifFalse: [ self error: 'Domain violation' ].
]

RDFSProperty >> checkRange: anRDFResource [
    ^ (range isNil or: [ anRDFResource class isSubclassOf: range ]) ifFalse: [ self error: 'Range violation' ].
]

]

================
File: src/RDFStore.st
================
Object subclass: RDFStore [
    | triples namedGraphs |

    RDFStore >> initialize [
        triples := OrderedCollection new.
        namedGraphs := Dictionary new.
    ]

    RDFStore >> addTriple: aTriple [
        triples add: aTriple.
    ]

    RDFStore >> addTriple: aTriple toGraph: graphName [
        (namedGraphs at: graphName ifAbsentPut: [RDFNamedGraph name: graphName]) addTriple: aTriple.
    ]

    RDFStore >> triplesDo: aBlock [
        triples do: aBlock.
    ]

    RDFStore >> triplesInGraph: graphName do: aBlock [
        (namedGraphs at: graphName ifAbsent: [^ self]) triplesDo: aBlock.
    ]
]

================
File: src/RDFStoreRDFSInference.st
================
RDFStore >> addTriple: aTriple [
    | predicate subject object |
    subject := aTriple subject.
    predicate := aTriple predicate.
    object := aTriple object.
    "Check domain and range constraints"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate checkDomain: subject.
        predicate checkRange: object.
    ].
    triples add: aTriple.
    "Handle subclass and subproperty inferences"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate subproperties do: [ :sub |
            triples add: (RDFTriple subject: subject predicate: sub object: object).
        ].
    ].
    (subject isKindOf: RDFSClass) ifTrue: [
        subject subclasses do: [ :sub |
            triples add: (RDFTriple subject: sub predicate: predicate object: object).
        ].
    ].
]

================
File: src/RDFTriple.st
================
Object subclass: RDFTriple [
    | subject predicate object |

    RDFTriple class >> subject: aSubject predicate: aPredicate object: anObject [
        ^ self new subject: aSubject predicate: aPredicate object: anObject.
    ]

    subject: aSubject predicate: aPredicate object: anObject [
        subject := aSubject.
        predicate := aPredicate.
        object := anObject.
    ]

    subject [
        ^ subject.
    ]

    predicate [
        ^ predicate.
    ]

    object [
        ^ object.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTriple(', subject printString, ', ', predicate printString, ', ', object printString, ')'.
    ]
]

================
File: src/RDFTypedLiteral.st
================
RDFLiteral subclass: RDFTypedLiteral [
    | datatype |

    RDFTypedLiteral class >> value: aValue type: aDatatypeUri [
        ^ self new value: aValue type: aDatatypeUri.
    ]

    value: aValue type: aDatatypeUri [
        super value: aValue.
        datatype := aDatatypeUri.
    ]

    datatype [
        ^ datatype.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTypedLiteral(', value printString, '^^', datatype, ')'.
    ]
]

================
File: src/SPARQLQuery.st
================
Object subclass: SPARQLQuery [
    | queryString |

    SPARQLQuery class >> query: aString [
        ^ self new query: aString.
    ]

    query: aString [
        queryString := aString.
    ]

    query [
        ^ queryString.
    ]

    executeOn: anRDFStore [
        | results |
        results := OrderedCollection new.
        "Parse the query and match against RDF triples in the store"
        "For simplicity, this example only handles basic SELECT queries with a single triple pattern"
        | subject predicate object pattern |
        (queryString beginsWith: 'SELECT') ifFalse: [ ^ results ].
        pattern := queryString copyFrom: (queryString indexOf: '{') + 1 to: (queryString indexOf: '}') - 1.
        subject := (pattern substrings: ' ') first.
        predicate := (pattern substrings: ' ') second.
        object := (pattern substrings: ' ') third.
        anRDFStore triplesDo: [ :triple |
            ((subject = '?' or: [ triple subject uri = subject ]) and:
             (predicate = '?' or: [ triple predicate uri = predicate ]) and:
             (object = '?' or: [ triple object value = object or: [ triple object uri = object ] ])) ifTrue: [
                results add: triple
            ].
        ].
        ^ results.
    ]
]

================
File: src/define-classes-properties.st
================
| personClass studentClass teachesProperty |
personClass := RDFSClass uri: 'http://example.org/Person'.
studentClass := RDFSClass uri: 'http://example.org/Student'.
personClass addSubclass: studentClass.
teachesProperty := RDFSProperty uri: 'http://example.org/teaches'.
teachesProperty domain: personClass.

================
File: stonerdf-repopack.txt
================
================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-07-27T23:17:19.067Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.
- Code comments have been removed.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

Additional User-Provided Header:
--------------------------------
StoneRDF repo

================================================================
Repository Files
================================================================

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# StoneRDF

_it might not happen_

This is a simple RDF library implementation in Smalltalk, primarily targetted at Pharo.

================
File: docs/notes.md
================
```
repopack --verbose -c ./repopack.config.json
```

================
File: docs/prompts.md
================
PetitParser:

================
File: docs/todo.md
================
# TODO

- [ ] figure out how to put it in an image
- [ ] figure out how to release it as a component
- [ ] figure out the GitHub etc bits of Glamourous Toolkit - https://book.gtoolkit.com/how-to-set-up-a-gt-github-repo-in-7--6jnhavaiy1r1smdayzj29bopu
- [ ] Turtle parser - PetitParser
- [ ] Turtle serializer
- [ ] docs
- [ ] tests
- [ ] graphic representation

================
File: examples/create-add-triples.st
================
| store subject predicate object triple |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/Alice'.
predicate := teachesProperty.
object := RDFResource uri: 'http://example.org/Math'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: examples/create-execute-query.st
================
query := SPARQLQuery query: 'SELECT ?s WHERE { ?s <http://example.org/property1> "Some value" }'.
results := store query: query.
Transcript show: results; cr.

================
File: examples/create-resource-literal.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: examples/create-triple.st
================
triple := RDFTriple subject: subject predicate: predicate object: object.

================
File: examples/named-graphs.st
================
| store graph subject predicate object triple |
store := RDFStore new.
graph := RDFNamedGraph name: 'http://example.org/graph1'.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple toGraph: 'http://example.org/graph1'.

================
File: examples/namespaces.st
================
| ns expandedUri compactUri |
ns := RDFNamespace prefix: 'ex' uri: 'http://example.org/'.
expandedUri := ns expand: 'ex:resource1'.
compactUri := ns compact: 'http://example.org/resource1'.

================
File: examples/print-triple.st
================
Transcript show: triple; cr.

================
File: examples/rdf-dataypes.st
================
| typedLiteral |
typedLiteral := RDFTypedLiteral value: '123' type: 'http://www.w3.org/2001/XMLSchema#integer'.

================
File: examples/store-create-resources-literals.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: repopack.config.json
================
{
    "output": {
        "filePath": "./docs/stonerdf-repopack.txt",
        "headerText": "StoneRDF repo",
        "removeComments": true
    },
    "ignore": {
        "useDefaultPatterns": true,
        "customPatterns": [
            "*.log"
        ]
    }
}

================
File: src/NamedGraph.st
================
Object subclass: RDFNamedGraph [
    | name triples |

    RDFNamedGraph class >> name: aName [
        ^ self new name: aName.
    ]

    name: aName [
        name := aName.
        triples := OrderedCollection new.
    ]

    name [
        ^ name.
    ]

    addTriple: aTriple [
        triples add: aTriple.
    ]

    triplesDo: aBlock [
        triples do: aBlock.
    ]
]

================
File: src/RDFLiteral.st
================
Object subclass: RDFLiteral [
    | value |

    RDFLiteral class >> value: aValue [
        ^ self new value: aValue.
    ]

    value: aValue [
        value := aValue.
    ]

    value [
        ^ value.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFLiteral(', value printString, ')'.
    ]
]

================
File: src/RDFNamespace.st
================
Object subclass: RDFNamespace [
    | prefix uri |

    RDFNamespace class >> prefix: aPrefix uri: anUri [
        ^ self new prefix: aPrefix uri: anUri.
    ]

    prefix: aPrefix uri: anUri [
        prefix := aPrefix.
        uri := anUri.
    ]

    expand: aCompactUri [
        | parts |
        parts := aCompactUri findTokens: ':'.
        ^ (prefix = parts first) ifTrue: [uri, parts second] ifFalse: [aCompactUri].
    ]

    compact: aFullUri [
        ^ (aFullUri beginsWith: uri) ifTrue: [prefix, ':', (aFullUri copyFrom: (uri size + 1) to: aFullUri size)] ifFalse: [aFullUri].
    ]

    prefix [
        ^ prefix.
    ]

    uri [
        ^ uri.
    ]
]

================
File: src/RDFProperty.st
================
RDFResource subclass: RDFProperty [
    printOn: aStream [
        aStream nextPutAll: 'RDFProperty(', self uri, ')'.
    ]
]

================
File: src/RDFResource.st
================
Object subclass: RDFResource [
    | uri |

    RDFResource class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
    ]

    uri [
        ^ uri.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFResource(', uri, ')'.
    ]
]

================
File: src/RDFSClass.st
================
Object subclass: RDFSClass [
    | uri subclasses |

    RDFSClass class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
        subclasses := OrderedCollection new.
    ]

    uri [
        ^ uri.
    ]

    addSubclass: aClass [
        subclasses add: aClass.
    ]

    subclasses [
        ^ subclasses.
    ]

    isSubclassOf: aClass [
        ^ (subclasses includes: aClass) ifTrue: [ true ] ifFalse: [ subclasses anySatisfy: [ :sub | sub isSubclassOf: aClass ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSClass(', uri, ')'.
    ]
]

================
File: src/RDFSProperty.st
================
RDFProperty subclass: RDFSProperty [
    | domain range subproperties |

    RDFSProperty class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        super uri: aString.
        subproperties := OrderedCollection new.
    ]

    domain: aClass [
        domain := aClass.
    ]

    range: aClass [
        range := aClass.
    ]

    domain [
        ^ domain.
    ]

    range [
        ^ range.
    ]

    addSubproperty: aProperty [
        subproperties add: aProperty.
    ]

    subproperties [
        ^ subproperties.
    ]

    isSubpropertyOf: aProperty [
        ^ (subproperties includes: aProperty) ifTrue: [ true ] ifFalse: [ subproperties anySatisfy: [ :sub | sub isSubpropertyOf: aProperty ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSProperty(', self uri, ')'.
    ]

RDFSProperty >> checkDomain: anRDFResource [
    ^ (domain isNil or: [ anRDFResource class isSubclassOf: domain ]) ifFalse: [ self error: 'Domain violation' ].
]

RDFSProperty >> checkRange: anRDFResource [
    ^ (range isNil or: [ anRDFResource class isSubclassOf: range ]) ifFalse: [ self error: 'Range violation' ].
]

]

================
File: src/RDFStore.st
================
Object subclass: RDFStore [
    | triples namedGraphs |

    RDFStore >> initialize [
        triples := OrderedCollection new.
        namedGraphs := Dictionary new.
    ]

    RDFStore >> addTriple: aTriple [
        triples add: aTriple.
    ]

    RDFStore >> addTriple: aTriple toGraph: graphName [
        (namedGraphs at: graphName ifAbsentPut: [RDFNamedGraph name: graphName]) addTriple: aTriple.
    ]

    RDFStore >> triplesDo: aBlock [
        triples do: aBlock.
    ]

    RDFStore >> triplesInGraph: graphName do: aBlock [
        (namedGraphs at: graphName ifAbsent: [^ self]) triplesDo: aBlock.
    ]
]

================
File: src/RDFStoreRDFSInference.st
================
RDFStore >> addTriple: aTriple [
    | predicate subject object |
    subject := aTriple subject.
    predicate := aTriple predicate.
    object := aTriple object.
    "Check domain and range constraints"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate checkDomain: subject.
        predicate checkRange: object.
    ].
    triples add: aTriple.
    "Handle subclass and subproperty inferences"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate subproperties do: [ :sub |
            triples add: (RDFTriple subject: subject predicate: sub object: object).
        ].
    ].
    (subject isKindOf: RDFSClass) ifTrue: [
        subject subclasses do: [ :sub |
            triples add: (RDFTriple subject: sub predicate: predicate object: object).
        ].
    ].
]

================
File: src/RDFTriple.st
================
Object subclass: RDFTriple [
    | subject predicate object |

    RDFTriple class >> subject: aSubject predicate: aPredicate object: anObject [
        ^ self new subject: aSubject predicate: aPredicate object: anObject.
    ]

    subject: aSubject predicate: aPredicate object: anObject [
        subject := aSubject.
        predicate := aPredicate.
        object := anObject.
    ]

    subject [
        ^ subject.
    ]

    predicate [
        ^ predicate.
    ]

    object [
        ^ object.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTriple(', subject printString, ', ', predicate printString, ', ', object printString, ')'.
    ]
]

================
File: src/RDFTypedLiteral.st
================
RDFLiteral subclass: RDFTypedLiteral [
    | datatype |

    RDFTypedLiteral class >> value: aValue type: aDatatypeUri [
        ^ self new value: aValue type: aDatatypeUri.
    ]

    value: aValue type: aDatatypeUri [
        super value: aValue.
        datatype := aDatatypeUri.
    ]

    datatype [
        ^ datatype.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTypedLiteral(', value printString, '^^', datatype, ')'.
    ]
]

================
File: src/SPARQLQuery.st
================
Object subclass: SPARQLQuery [
    | queryString |

    SPARQLQuery class >> query: aString [
        ^ self new query: aString.
    ]

    query: aString [
        queryString := aString.
    ]

    query [
        ^ queryString.
    ]

    executeOn: anRDFStore [
        | results |
        results := OrderedCollection new.
        "Parse the query and match against RDF triples in the store"
        "For simplicity, this example only handles basic SELECT queries with a single triple pattern"
        | subject predicate object pattern |
        (queryString beginsWith: 'SELECT') ifFalse: [ ^ results ].
        pattern := queryString copyFrom: (queryString indexOf: '{') + 1 to: (queryString indexOf: '}') - 1.
        subject := (pattern substrings: ' ') first.
        predicate := (pattern substrings: ' ') second.
        object := (pattern substrings: ' ') third.
        anRDFStore triplesDo: [ :triple |
            ((subject = '?' or: [ triple subject uri = subject ]) and:
             (predicate = '?' or: [ triple predicate uri = predicate ]) and:
             (object = '?' or: [ triple object value = object or: [ triple object uri = object ] ])) ifTrue: [
                results add: triple
            ].
        ].
        ^ results.
    ]
]

================
File: src/define-classes-properties.st
================
| personClass studentClass teachesProperty |
personClass := RDFSClass uri: 'http://example.org/Person'.
studentClass := RDFSClass uri: 'http://example.org/Student'.
personClass addSubclass: studentClass.
teachesProperty := RDFSProperty uri: 'http://example.org/teaches'.
teachesProperty domain: personClass.

================
File: stonerdf-repopack.txt
================
================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-07-27T23:10:46.938Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.
- Code comments have been removed.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

Additional User-Provided Header:
--------------------------------
StoneRDF repo

================================================================
Repository Files
================================================================

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# StoneRDF
it might not happen

================
File: docs/notes.md
================
```
repopack --verbose -c ./repopack.config.json
```

================
File: docs/prompts.md
================
PetitParser:

================
File: examples/create-add-triples.st
================
| store subject predicate object triple |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/Alice'.
predicate := teachesProperty.
object := RDFResource uri: 'http://example.org/Math'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: examples/create-execute-query.st
================
query := SPARQLQuery query: 'SELECT ?s WHERE { ?s <http://example.org/property1> "Some value" }'.
results := store query: query.
Transcript show: results; cr.

================
File: examples/create-resource-literal.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: examples/create-triple.st
================
triple := RDFTriple subject: subject predicate: predicate object: object.

================
File: examples/named-graphs.st
================
| store graph subject predicate object triple |
store := RDFStore new.
graph := RDFNamedGraph name: 'http://example.org/graph1'.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple toGraph: 'http://example.org/graph1'.

================
File: examples/namespaces.st
================
| ns expandedUri compactUri |
ns := RDFNamespace prefix: 'ex' uri: 'http://example.org/'.
expandedUri := ns expand: 'ex:resource1'.
compactUri := ns compact: 'http://example.org/resource1'.

================
File: examples/print-triple.st
================
Transcript show: triple; cr.

================
File: examples/rdf-dataypes.st
================
| typedLiteral |
typedLiteral := RDFTypedLiteral value: '123' type: 'http://www.w3.org/2001/XMLSchema#integer'.

================
File: examples/store-create-resources-literals.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: repopack.config.json
================
{
    "output": {
        "filePath": "./docs/stonerdf-repopack.txt",
        "headerText": "StoneRDF repo",
        "removeComments": true
    },
    "ignore": {
        "useDefaultPatterns": true,
        "customPatterns": [
            "*.log"
        ]
    }
}

================
File: src/NamedGraph.st
================
Object subclass: RDFNamedGraph [
    | name triples |

    RDFNamedGraph class >> name: aName [
        ^ self new name: aName.
    ]

    name: aName [
        name := aName.
        triples := OrderedCollection new.
    ]

    name [
        ^ name.
    ]

    addTriple: aTriple [
        triples add: aTriple.
    ]

    triplesDo: aBlock [
        triples do: aBlock.
    ]
]

================
File: src/RDFLiteral.st
================
Object subclass: RDFLiteral [
    | value |

    RDFLiteral class >> value: aValue [
        ^ self new value: aValue.
    ]

    value: aValue [
        value := aValue.
    ]

    value [
        ^ value.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFLiteral(', value printString, ')'.
    ]
]

================
File: src/RDFNamespace.st
================
Object subclass: RDFNamespace [
    | prefix uri |

    RDFNamespace class >> prefix: aPrefix uri: anUri [
        ^ self new prefix: aPrefix uri: anUri.
    ]

    prefix: aPrefix uri: anUri [
        prefix := aPrefix.
        uri := anUri.
    ]

    expand: aCompactUri [
        | parts |
        parts := aCompactUri findTokens: ':'.
        ^ (prefix = parts first) ifTrue: [uri, parts second] ifFalse: [aCompactUri].
    ]

    compact: aFullUri [
        ^ (aFullUri beginsWith: uri) ifTrue: [prefix, ':', (aFullUri copyFrom: (uri size + 1) to: aFullUri size)] ifFalse: [aFullUri].
    ]

    prefix [
        ^ prefix.
    ]

    uri [
        ^ uri.
    ]
]

================
File: src/RDFProperty.st
================
RDFResource subclass: RDFProperty [
    printOn: aStream [
        aStream nextPutAll: 'RDFProperty(', self uri, ')'.
    ]
]

================
File: src/RDFResource.st
================
Object subclass: RDFResource [
    | uri |

    RDFResource class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
    ]

    uri [
        ^ uri.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFResource(', uri, ')'.
    ]
]

================
File: src/RDFSClass.st
================
Object subclass: RDFSClass [
    | uri subclasses |

    RDFSClass class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
        subclasses := OrderedCollection new.
    ]

    uri [
        ^ uri.
    ]

    addSubclass: aClass [
        subclasses add: aClass.
    ]

    subclasses [
        ^ subclasses.
    ]

    isSubclassOf: aClass [
        ^ (subclasses includes: aClass) ifTrue: [ true ] ifFalse: [ subclasses anySatisfy: [ :sub | sub isSubclassOf: aClass ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSClass(', uri, ')'.
    ]
]

================
File: src/RDFSProperty.st
================
RDFProperty subclass: RDFSProperty [
    | domain range subproperties |

    RDFSProperty class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        super uri: aString.
        subproperties := OrderedCollection new.
    ]

    domain: aClass [
        domain := aClass.
    ]

    range: aClass [
        range := aClass.
    ]

    domain [
        ^ domain.
    ]

    range [
        ^ range.
    ]

    addSubproperty: aProperty [
        subproperties add: aProperty.
    ]

    subproperties [
        ^ subproperties.
    ]

    isSubpropertyOf: aProperty [
        ^ (subproperties includes: aProperty) ifTrue: [ true ] ifFalse: [ subproperties anySatisfy: [ :sub | sub isSubpropertyOf: aProperty ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSProperty(', self uri, ')'.
    ]

RDFSProperty >> checkDomain: anRDFResource [
    ^ (domain isNil or: [ anRDFResource class isSubclassOf: domain ]) ifFalse: [ self error: 'Domain violation' ].
]

RDFSProperty >> checkRange: anRDFResource [
    ^ (range isNil or: [ anRDFResource class isSubclassOf: range ]) ifFalse: [ self error: 'Range violation' ].
]

]

================
File: src/RDFStore.st
================
Object subclass: RDFStore [
    | triples namedGraphs |

    RDFStore >> initialize [
        triples := OrderedCollection new.
        namedGraphs := Dictionary new.
    ]

    RDFStore >> addTriple: aTriple [
        triples add: aTriple.
    ]

    RDFStore >> addTriple: aTriple toGraph: graphName [
        (namedGraphs at: graphName ifAbsentPut: [RDFNamedGraph name: graphName]) addTriple: aTriple.
    ]

    RDFStore >> triplesDo: aBlock [
        triples do: aBlock.
    ]

    RDFStore >> triplesInGraph: graphName do: aBlock [
        (namedGraphs at: graphName ifAbsent: [^ self]) triplesDo: aBlock.
    ]
]

================
File: src/RDFStoreRDFSInference.st
================
RDFStore >> addTriple: aTriple [
    | predicate subject object |
    subject := aTriple subject.
    predicate := aTriple predicate.
    object := aTriple object.
    "Check domain and range constraints"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate checkDomain: subject.
        predicate checkRange: object.
    ].
    triples add: aTriple.
    "Handle subclass and subproperty inferences"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate subproperties do: [ :sub |
            triples add: (RDFTriple subject: subject predicate: sub object: object).
        ].
    ].
    (subject isKindOf: RDFSClass) ifTrue: [
        subject subclasses do: [ :sub |
            triples add: (RDFTriple subject: sub predicate: predicate object: object).
        ].
    ].
]

================
File: src/RDFTriple.st
================
Object subclass: RDFTriple [
    | subject predicate object |

    RDFTriple class >> subject: aSubject predicate: aPredicate object: anObject [
        ^ self new subject: aSubject predicate: aPredicate object: anObject.
    ]

    subject: aSubject predicate: aPredicate object: anObject [
        subject := aSubject.
        predicate := aPredicate.
        object := anObject.
    ]

    subject [
        ^ subject.
    ]

    predicate [
        ^ predicate.
    ]

    object [
        ^ object.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTriple(', subject printString, ', ', predicate printString, ', ', object printString, ')'.
    ]
]

================
File: src/RDFTypedLiteral.st
================
RDFLiteral subclass: RDFTypedLiteral [
    | datatype |

    RDFTypedLiteral class >> value: aValue type: aDatatypeUri [
        ^ self new value: aValue type: aDatatypeUri.
    ]

    value: aValue type: aDatatypeUri [
        super value: aValue.
        datatype := aDatatypeUri.
    ]

    datatype [
        ^ datatype.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTypedLiteral(', value printString, '^^', datatype, ')'.
    ]
]

================
File: src/SPARQLQuery.st
================
Object subclass: SPARQLQuery [
    | queryString |

    SPARQLQuery class >> query: aString [
        ^ self new query: aString.
    ]

    query: aString [
        queryString := aString.
    ]

    query [
        ^ queryString.
    ]

    executeOn: anRDFStore [
        | results |
        results := OrderedCollection new.
        "Parse the query and match against RDF triples in the store"
        "For simplicity, this example only handles basic SELECT queries with a single triple pattern"
        | subject predicate object pattern |
        (queryString beginsWith: 'SELECT') ifFalse: [ ^ results ].
        pattern := queryString copyFrom: (queryString indexOf: '{') + 1 to: (queryString indexOf: '}') - 1.
        subject := (pattern substrings: ' ') first.
        predicate := (pattern substrings: ' ') second.
        object := (pattern substrings: ' ') third.
        anRDFStore triplesDo: [ :triple |
            ((subject = '?' or: [ triple subject uri = subject ]) and:
             (predicate = '?' or: [ triple predicate uri = predicate ]) and:
             (object = '?' or: [ triple object value = object or: [ triple object uri = object ] ])) ifTrue: [
                results add: triple
            ].
        ].
        ^ results.
    ]
]

================
File: src/define-classes-properties.st
================
| personClass studentClass teachesProperty |
personClass := RDFSClass uri: 'http://example.org/Person'.
studentClass := RDFSClass uri: 'http://example.org/Student'.
personClass addSubclass: studentClass.
teachesProperty := RDFSProperty uri: 'http://example.org/teaches'.
teachesProperty domain: personClass.
