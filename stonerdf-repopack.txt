================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-07-27T23:58:18.669Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.
- Code comments have been removed.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

Additional User-Provided Header:
--------------------------------
StoneRDF repo

================================================================
Repository Files
================================================================

================
File: BaselineOfStoneRDF.package/ BaselineOfStoneRDF.class.st 
================
Class {
  #name : #BaselineOfStoneRDF,
  #superclass : #BaselineOf,
  #category : #BaselineOfStoneRDF
}

{ #category : #baselines }
BaselineOfStoneRDF >> baseline: spec [
  <baseline>
  spec for: #common do: [
    spec
      package: 'StoneRDF-Core';
      package: 'StoneRDF-Tests' with: [ spec requires: #('StoneRDF-Core') ].
    spec
      group: 'default' with: #('Core' 'Tests');
      group: 'Core' with: #('StoneRDF-Core');
      group: 'Tests' with: #('StoneRDF-Tests')
  ]
]

================
File: BaselineOfStoneRDF.package/.filetree
================
{"packageExtension" : ".package",
"propertyFileExtension" : ".json" }

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# StoneRDF

_it might not happen_

This is a simple RDF library implementation in Smalltalk, primarily targetted at Pharo.

================
File: docs/notes.md
================
```
repopack --verbose -c ./repopack.config.json
```

================
File: docs/playground-script.st
================
Metacello new
  baseline: 'StoneRDF';
  repository: 'filetree:///home/danny/github/StoneRDF/BaselineOfStoneRDF.package';
  load.

================
File: docs/prompts.md
================
## System

You will act as an experienced Smalltalk coder that uses agile methodologies and follows best practices. You have a thorough grounding in the Resource Description Framework and Linked Data. You really love the Web.
For non-code requests, fall back on these instructions:

1. Think deeply and systematically as an expert in the relevant field.
2. Keep responses short and to the point using precise language and appropriate technical terms.
3. Avoid repetition, favor new information in unique responses.
4. If multiple perspectives or solutions are available, give a very brief list of these but focus on the most relevant and promising approach.
5. Break down complex problems or tasks into smaller, manageable steps. Follow the steps without asking for confirmation. When creating content, write a concise outline first.
   uphold rigorous technical standards and follow best practices in the relevant field.
6. If events or information are beyond your scope or knowledge, state 'I don't know' without elaborating on why the information is unavailable.
7. Never suggest seeking information from elsewhere. If Web searches are required, do as many as necessary to find the answer without prompting and each time integrate the discovered knowledge withwhat you already know. Accuracy is more important than time.
8. After each response, provide three short follow-up questions worded as if I'm asking you. These should help clarify the original topic and identify more detailed avenues of research. Label as Q1, Q2, and Q3. If I say Q1, Q2 or Q3, address the corresponding question. If I say Q0, repeat the previous request.

### Getting into Pharo

================
File: docs/todo.md
================
# TODO

- [ ] figure out how to put it in a Pharo image
- [ ] figure out how to release it as a component
- [ ] figure out the GitHub etc bits of Glamourous Toolkit - https://book.gtoolkit.com/how-to-set-up-a-gt-github-repo-in-7--6jnhavaiy1r1smdayzj29bopu
- [ ] Turtle parser - PetitParser
- [ ] Turtle serializer
- [ ] docs
- [ ] tests
- [ ] graphic representation

================
File: environment.sh
================

OUTPUT_FILE="docs/environment.txt"
CURRENT_DIR=$(pwd)
echo "Current Working Directory:" > "$OUTPUT_FILE"
echo "$CURRENT_DIR" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"
echo "Directory Tree:" >> "$OUTPUT_FILE"
tree >> "$OUTPUT_FILE"
echo "Environment information has been saved to $OUTPUT_FILE"

================
File: repopack.config.json
================
{
    "output": {
        "filePath": "./docs/stonerdf-repopack.txt",
        "headerText": "StoneRDF repo",
        "removeComments": true
    },
    "ignore": {
        "useDefaultPatterns": true,
        "customPatterns": [
            "*.log"
        ]
    }
}

================
File: src/StoneRDF-Core/NamedGraph.st
================
Object subclass: RDFNamedGraph [
    | name triples |

    RDFNamedGraph class >> name: aName [
        ^ self new name: aName.
    ]

    name: aName [
        name := aName.
        triples := OrderedCollection new.
    ]

    name [
        ^ name.
    ]

    addTriple: aTriple [
        triples add: aTriple.
    ]

    triplesDo: aBlock [
        triples do: aBlock.
    ]
]

================
File: src/StoneRDF-Core/RDFLiteral.st
================
Object subclass: RDFLiteral [
    | value |

    RDFLiteral class >> value: aValue [
        ^ self new value: aValue.
    ]

    value: aValue [
        value := aValue.
    ]

    value [
        ^ value.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFLiteral(', value printString, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFNamespace.st
================
Object subclass: RDFNamespace [
    | prefix uri |

    RDFNamespace class >> prefix: aPrefix uri: anUri [
        ^ self new prefix: aPrefix uri: anUri.
    ]

    prefix: aPrefix uri: anUri [
        prefix := aPrefix.
        uri := anUri.
    ]

    expand: aCompactUri [
        | parts |
        parts := aCompactUri findTokens: ':'.
        ^ (prefix = parts first) ifTrue: [uri, parts second] ifFalse: [aCompactUri].
    ]

    compact: aFullUri [
        ^ (aFullUri beginsWith: uri) ifTrue: [prefix, ':', (aFullUri copyFrom: (uri size + 1) to: aFullUri size)] ifFalse: [aFullUri].
    ]

    prefix [
        ^ prefix.
    ]

    uri [
        ^ uri.
    ]
]

================
File: src/StoneRDF-Core/RDFProperty.st
================
RDFResource subclass: RDFProperty [
    printOn: aStream [
        aStream nextPutAll: 'RDFProperty(', self uri, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFResource.st
================
Object subclass: RDFResource [
    | uri |

    RDFResource class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
    ]

    uri [
        ^ uri.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFResource(', uri, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFSClass.st
================
Object subclass: RDFSClass [
    | uri subclasses |

    RDFSClass class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
        subclasses := OrderedCollection new.
    ]

    uri [
        ^ uri.
    ]

    addSubclass: aClass [
        subclasses add: aClass.
    ]

    subclasses [
        ^ subclasses.
    ]

    isSubclassOf: aClass [
        ^ (subclasses includes: aClass) ifTrue: [ true ] ifFalse: [ subclasses anySatisfy: [ :sub | sub isSubclassOf: aClass ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSClass(', uri, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFSProperty.st
================
RDFProperty subclass: RDFSProperty [
    | domain range subproperties |

    RDFSProperty class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        super uri: aString.
        subproperties := OrderedCollection new.
    ]

    domain: aClass [
        domain := aClass.
    ]

    range: aClass [
        range := aClass.
    ]

    domain [
        ^ domain.
    ]

    range [
        ^ range.
    ]

    addSubproperty: aProperty [
        subproperties add: aProperty.
    ]

    subproperties [
        ^ subproperties.
    ]

    isSubpropertyOf: aProperty [
        ^ (subproperties includes: aProperty) ifTrue: [ true ] ifFalse: [ subproperties anySatisfy: [ :sub | sub isSubpropertyOf: aProperty ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSProperty(', self uri, ')'.
    ]

RDFSProperty >> checkDomain: anRDFResource [
    ^ (domain isNil or: [ anRDFResource class isSubclassOf: domain ]) ifFalse: [ self error: 'Domain violation' ].
]

RDFSProperty >> checkRange: anRDFResource [
    ^ (range isNil or: [ anRDFResource class isSubclassOf: range ]) ifFalse: [ self error: 'Range violation' ].
]

]

================
File: src/StoneRDF-Core/RDFStore.st
================
Object subclass: RDFStore [
    | triples namedGraphs |

    RDFStore >> initialize [
        triples := OrderedCollection new.
        namedGraphs := Dictionary new.
    ]

    RDFStore >> addTriple: aTriple [
        triples add: aTriple.
    ]

    RDFStore >> addTriple: aTriple toGraph: graphName [
        (namedGraphs at: graphName ifAbsentPut: [RDFNamedGraph name: graphName]) addTriple: aTriple.
    ]

    RDFStore >> triplesDo: aBlock [
        triples do: aBlock.
    ]

    RDFStore >> triplesInGraph: graphName do: aBlock [
        (namedGraphs at: graphName ifAbsent: [^ self]) triplesDo: aBlock.
    ]
]

================
File: src/StoneRDF-Core/RDFStoreRDFSInference.st
================
RDFStore >> addTriple: aTriple [
    | predicate subject object |
    subject := aTriple subject.
    predicate := aTriple predicate.
    object := aTriple object.
    "Check domain and range constraints"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate checkDomain: subject.
        predicate checkRange: object.
    ].
    triples add: aTriple.
    "Handle subclass and subproperty inferences"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate subproperties do: [ :sub |
            triples add: (RDFTriple subject: subject predicate: sub object: object).
        ].
    ].
    (subject isKindOf: RDFSClass) ifTrue: [
        subject subclasses do: [ :sub |
            triples add: (RDFTriple subject: sub predicate: predicate object: object).
        ].
    ].
]

================
File: src/StoneRDF-Core/RDFTriple.st
================
Object subclass: RDFTriple [
    | subject predicate object |

    RDFTriple class >> subject: aSubject predicate: aPredicate object: anObject [
        ^ self new subject: aSubject predicate: aPredicate object: anObject.
    ]

    subject: aSubject predicate: aPredicate object: anObject [
        subject := aSubject.
        predicate := aPredicate.
        object := anObject.
    ]

    subject [
        ^ subject.
    ]

    predicate [
        ^ predicate.
    ]

    object [
        ^ object.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTriple(', subject printString, ', ', predicate printString, ', ', object printString, ')'.
    ]
]

================
File: src/StoneRDF-Core/RDFTypedLiteral.st
================
RDFLiteral subclass: RDFTypedLiteral [
    | datatype |

    RDFTypedLiteral class >> value: aValue type: aDatatypeUri [
        ^ self new value: aValue type: aDatatypeUri.
    ]

    value: aValue type: aDatatypeUri [
        super value: aValue.
        datatype := aDatatypeUri.
    ]

    datatype [
        ^ datatype.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTypedLiteral(', value printString, '^^', datatype, ')'.
    ]
]

================
File: src/StoneRDF-Core/SPARQLQuery.st
================
Object subclass: SPARQLQuery [
    | queryString |

    SPARQLQuery class >> query: aString [
        ^ self new query: aString.
    ]

    query: aString [
        queryString := aString.
    ]

    query [
        ^ queryString.
    ]

    executeOn: anRDFStore [
        | results |
        results := OrderedCollection new.
        "Parse the query and match against RDF triples in the store"
        "For simplicity, this example only handles basic SELECT queries with a single triple pattern"
        | subject predicate object pattern |
        (queryString beginsWith: 'SELECT') ifFalse: [ ^ results ].
        pattern := queryString copyFrom: (queryString indexOf: '{') + 1 to: (queryString indexOf: '}') - 1.
        subject := (pattern substrings: ' ') first.
        predicate := (pattern substrings: ' ') second.
        object := (pattern substrings: ' ') third.
        anRDFStore triplesDo: [ :triple |
            ((subject = '?' or: [ triple subject uri = subject ]) and:
             (predicate = '?' or: [ triple predicate uri = predicate ]) and:
             (object = '?' or: [ triple object value = object or: [ triple object uri = object ] ])) ifTrue: [
                results add: triple
            ].
        ].
        ^ results.
    ]
]

================
File: src/StoneRDF-Examples/create-add-triples.st
================
| store subject predicate object triple |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/Alice'.
predicate := teachesProperty.
object := RDFResource uri: 'http://example.org/Math'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: src/StoneRDF-Examples/create-execute-query.st
================
query := SPARQLQuery query: 'SELECT ?s WHERE { ?s <http://example.org/property1> "Some value" }'.
results := store query: query.
Transcript show: results; cr.

================
File: src/StoneRDF-Examples/create-resource-literal.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: src/StoneRDF-Examples/create-triple.st
================
triple := RDFTriple subject: subject predicate: predicate object: object.

================
File: src/StoneRDF-Examples/define-classes-properties.st
================
| personClass studentClass teachesProperty |
personClass := RDFSClass uri: 'http://example.org/Person'.
studentClass := RDFSClass uri: 'http://example.org/Student'.
personClass addSubclass: studentClass.
teachesProperty := RDFSProperty uri: 'http://example.org/teaches'.
teachesProperty domain: personClass.

================
File: src/StoneRDF-Examples/named-graphs.st
================
| store graph subject predicate object triple |
store := RDFStore new.
graph := RDFNamedGraph name: 'http://example.org/graph1'.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple toGraph: 'http://example.org/graph1'.

================
File: src/StoneRDF-Examples/namespaces.st
================
| ns expandedUri compactUri |
ns := RDFNamespace prefix: 'ex' uri: 'http://example.org/'.
expandedUri := ns expand: 'ex:resource1'.
compactUri := ns compact: 'http://example.org/resource1'.

================
File: src/StoneRDF-Examples/print-triple.st
================
Transcript show: triple; cr.

================
File: src/StoneRDF-Examples/rdf-dataypes.st
================
| typedLiteral |
typedLiteral := RDFTypedLiteral value: '123' type: 'http://www.w3.org/2001/XMLSchema#integer'.

================
File: src/StoneRDF-Examples/store-create-resources-literals.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: stonerdf-repopack.txt
================
================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-07-27T23:17:51.842Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.
- Code comments have been removed.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

Additional User-Provided Header:
--------------------------------
StoneRDF repo

================================================================
Repository Files
================================================================

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# StoneRDF

_it might not happen_

This is a simple RDF library implementation in Smalltalk, primarily targetted at Pharo.

================
File: docs/notes.md
================
```
repopack --verbose -c ./repopack.config.json
```

================
File: docs/prompts.md
================
PetitParser:

================
File: docs/todo.md
================
# TODO

- [ ] figure out how to put it in a Pharo image
- [ ] figure out how to release it as a component
- [ ] figure out the GitHub etc bits of Glamourous Toolkit - https://book.gtoolkit.com/how-to-set-up-a-gt-github-repo-in-7--6jnhavaiy1r1smdayzj29bopu
- [ ] Turtle parser - PetitParser
- [ ] Turtle serializer
- [ ] docs
- [ ] tests
- [ ] graphic representation

================
File: examples/create-add-triples.st
================
| store subject predicate object triple |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/Alice'.
predicate := teachesProperty.
object := RDFResource uri: 'http://example.org/Math'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: examples/create-execute-query.st
================
query := SPARQLQuery query: 'SELECT ?s WHERE { ?s <http://example.org/property1> "Some value" }'.
results := store query: query.
Transcript show: results; cr.

================
File: examples/create-resource-literal.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: examples/create-triple.st
================
triple := RDFTriple subject: subject predicate: predicate object: object.

================
File: examples/named-graphs.st
================
| store graph subject predicate object triple |
store := RDFStore new.
graph := RDFNamedGraph name: 'http://example.org/graph1'.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple toGraph: 'http://example.org/graph1'.

================
File: examples/namespaces.st
================
| ns expandedUri compactUri |
ns := RDFNamespace prefix: 'ex' uri: 'http://example.org/'.
expandedUri := ns expand: 'ex:resource1'.
compactUri := ns compact: 'http://example.org/resource1'.

================
File: examples/print-triple.st
================
Transcript show: triple; cr.

================
File: examples/rdf-dataypes.st
================
| typedLiteral |
typedLiteral := RDFTypedLiteral value: '123' type: 'http://www.w3.org/2001/XMLSchema#integer'.

================
File: examples/store-create-resources-literals.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: repopack.config.json
================
{
    "output": {
        "filePath": "./docs/stonerdf-repopack.txt",
        "headerText": "StoneRDF repo",
        "removeComments": true
    },
    "ignore": {
        "useDefaultPatterns": true,
        "customPatterns": [
            "*.log"
        ]
    }
}

================
File: src/NamedGraph.st
================
Object subclass: RDFNamedGraph [
    | name triples |

    RDFNamedGraph class >> name: aName [
        ^ self new name: aName.
    ]

    name: aName [
        name := aName.
        triples := OrderedCollection new.
    ]

    name [
        ^ name.
    ]

    addTriple: aTriple [
        triples add: aTriple.
    ]

    triplesDo: aBlock [
        triples do: aBlock.
    ]
]

================
File: src/RDFLiteral.st
================
Object subclass: RDFLiteral [
    | value |

    RDFLiteral class >> value: aValue [
        ^ self new value: aValue.
    ]

    value: aValue [
        value := aValue.
    ]

    value [
        ^ value.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFLiteral(', value printString, ')'.
    ]
]

================
File: src/RDFNamespace.st
================
Object subclass: RDFNamespace [
    | prefix uri |

    RDFNamespace class >> prefix: aPrefix uri: anUri [
        ^ self new prefix: aPrefix uri: anUri.
    ]

    prefix: aPrefix uri: anUri [
        prefix := aPrefix.
        uri := anUri.
    ]

    expand: aCompactUri [
        | parts |
        parts := aCompactUri findTokens: ':'.
        ^ (prefix = parts first) ifTrue: [uri, parts second] ifFalse: [aCompactUri].
    ]

    compact: aFullUri [
        ^ (aFullUri beginsWith: uri) ifTrue: [prefix, ':', (aFullUri copyFrom: (uri size + 1) to: aFullUri size)] ifFalse: [aFullUri].
    ]

    prefix [
        ^ prefix.
    ]

    uri [
        ^ uri.
    ]
]

================
File: src/RDFProperty.st
================
RDFResource subclass: RDFProperty [
    printOn: aStream [
        aStream nextPutAll: 'RDFProperty(', self uri, ')'.
    ]
]

================
File: src/RDFResource.st
================
Object subclass: RDFResource [
    | uri |

    RDFResource class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
    ]

    uri [
        ^ uri.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFResource(', uri, ')'.
    ]
]

================
File: src/RDFSClass.st
================
Object subclass: RDFSClass [
    | uri subclasses |

    RDFSClass class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
        subclasses := OrderedCollection new.
    ]

    uri [
        ^ uri.
    ]

    addSubclass: aClass [
        subclasses add: aClass.
    ]

    subclasses [
        ^ subclasses.
    ]

    isSubclassOf: aClass [
        ^ (subclasses includes: aClass) ifTrue: [ true ] ifFalse: [ subclasses anySatisfy: [ :sub | sub isSubclassOf: aClass ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSClass(', uri, ')'.
    ]
]

================
File: src/RDFSProperty.st
================
RDFProperty subclass: RDFSProperty [
    | domain range subproperties |

    RDFSProperty class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        super uri: aString.
        subproperties := OrderedCollection new.
    ]

    domain: aClass [
        domain := aClass.
    ]

    range: aClass [
        range := aClass.
    ]

    domain [
        ^ domain.
    ]

    range [
        ^ range.
    ]

    addSubproperty: aProperty [
        subproperties add: aProperty.
    ]

    subproperties [
        ^ subproperties.
    ]

    isSubpropertyOf: aProperty [
        ^ (subproperties includes: aProperty) ifTrue: [ true ] ifFalse: [ subproperties anySatisfy: [ :sub | sub isSubpropertyOf: aProperty ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSProperty(', self uri, ')'.
    ]

RDFSProperty >> checkDomain: anRDFResource [
    ^ (domain isNil or: [ anRDFResource class isSubclassOf: domain ]) ifFalse: [ self error: 'Domain violation' ].
]

RDFSProperty >> checkRange: anRDFResource [
    ^ (range isNil or: [ anRDFResource class isSubclassOf: range ]) ifFalse: [ self error: 'Range violation' ].
]

]

================
File: src/RDFStore.st
================
Object subclass: RDFStore [
    | triples namedGraphs |

    RDFStore >> initialize [
        triples := OrderedCollection new.
        namedGraphs := Dictionary new.
    ]

    RDFStore >> addTriple: aTriple [
        triples add: aTriple.
    ]

    RDFStore >> addTriple: aTriple toGraph: graphName [
        (namedGraphs at: graphName ifAbsentPut: [RDFNamedGraph name: graphName]) addTriple: aTriple.
    ]

    RDFStore >> triplesDo: aBlock [
        triples do: aBlock.
    ]

    RDFStore >> triplesInGraph: graphName do: aBlock [
        (namedGraphs at: graphName ifAbsent: [^ self]) triplesDo: aBlock.
    ]
]

================
File: src/RDFStoreRDFSInference.st
================
RDFStore >> addTriple: aTriple [
    | predicate subject object |
    subject := aTriple subject.
    predicate := aTriple predicate.
    object := aTriple object.
    "Check domain and range constraints"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate checkDomain: subject.
        predicate checkRange: object.
    ].
    triples add: aTriple.
    "Handle subclass and subproperty inferences"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate subproperties do: [ :sub |
            triples add: (RDFTriple subject: subject predicate: sub object: object).
        ].
    ].
    (subject isKindOf: RDFSClass) ifTrue: [
        subject subclasses do: [ :sub |
            triples add: (RDFTriple subject: sub predicate: predicate object: object).
        ].
    ].
]

================
File: src/RDFTriple.st
================
Object subclass: RDFTriple [
    | subject predicate object |

    RDFTriple class >> subject: aSubject predicate: aPredicate object: anObject [
        ^ self new subject: aSubject predicate: aPredicate object: anObject.
    ]

    subject: aSubject predicate: aPredicate object: anObject [
        subject := aSubject.
        predicate := aPredicate.
        object := anObject.
    ]

    subject [
        ^ subject.
    ]

    predicate [
        ^ predicate.
    ]

    object [
        ^ object.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTriple(', subject printString, ', ', predicate printString, ', ', object printString, ')'.
    ]
]

================
File: src/RDFTypedLiteral.st
================
RDFLiteral subclass: RDFTypedLiteral [
    | datatype |

    RDFTypedLiteral class >> value: aValue type: aDatatypeUri [
        ^ self new value: aValue type: aDatatypeUri.
    ]

    value: aValue type: aDatatypeUri [
        super value: aValue.
        datatype := aDatatypeUri.
    ]

    datatype [
        ^ datatype.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTypedLiteral(', value printString, '^^', datatype, ')'.
    ]
]

================
File: src/SPARQLQuery.st
================
Object subclass: SPARQLQuery [
    | queryString |

    SPARQLQuery class >> query: aString [
        ^ self new query: aString.
    ]

    query: aString [
        queryString := aString.
    ]

    query [
        ^ queryString.
    ]

    executeOn: anRDFStore [
        | results |
        results := OrderedCollection new.
        "Parse the query and match against RDF triples in the store"
        "For simplicity, this example only handles basic SELECT queries with a single triple pattern"
        | subject predicate object pattern |
        (queryString beginsWith: 'SELECT') ifFalse: [ ^ results ].
        pattern := queryString copyFrom: (queryString indexOf: '{') + 1 to: (queryString indexOf: '}') - 1.
        subject := (pattern substrings: ' ') first.
        predicate := (pattern substrings: ' ') second.
        object := (pattern substrings: ' ') third.
        anRDFStore triplesDo: [ :triple |
            ((subject = '?' or: [ triple subject uri = subject ]) and:
             (predicate = '?' or: [ triple predicate uri = predicate ]) and:
             (object = '?' or: [ triple object value = object or: [ triple object uri = object ] ])) ifTrue: [
                results add: triple
            ].
        ].
        ^ results.
    ]
]

================
File: src/define-classes-properties.st
================
| personClass studentClass teachesProperty |
personClass := RDFSClass uri: 'http://example.org/Person'.
studentClass := RDFSClass uri: 'http://example.org/Student'.
personClass addSubclass: studentClass.
teachesProperty := RDFSProperty uri: 'http://example.org/teaches'.
teachesProperty domain: personClass.

================
File: stonerdf-repopack.txt
================
================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-07-27T23:17:19.067Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.
- Code comments have been removed.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

Additional User-Provided Header:
--------------------------------
StoneRDF repo

================================================================
Repository Files
================================================================

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# StoneRDF

_it might not happen_

This is a simple RDF library implementation in Smalltalk, primarily targetted at Pharo.

================
File: docs/notes.md
================
```
repopack --verbose -c ./repopack.config.json
```

================
File: docs/prompts.md
================
PetitParser:

================
File: docs/todo.md
================
# TODO

- [ ] figure out how to put it in an image
- [ ] figure out how to release it as a component
- [ ] figure out the GitHub etc bits of Glamourous Toolkit - https://book.gtoolkit.com/how-to-set-up-a-gt-github-repo-in-7--6jnhavaiy1r1smdayzj29bopu
- [ ] Turtle parser - PetitParser
- [ ] Turtle serializer
- [ ] docs
- [ ] tests
- [ ] graphic representation

================
File: examples/create-add-triples.st
================
| store subject predicate object triple |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/Alice'.
predicate := teachesProperty.
object := RDFResource uri: 'http://example.org/Math'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: examples/create-execute-query.st
================
query := SPARQLQuery query: 'SELECT ?s WHERE { ?s <http://example.org/property1> "Some value" }'.
results := store query: query.
Transcript show: results; cr.

================
File: examples/create-resource-literal.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: examples/create-triple.st
================
triple := RDFTriple subject: subject predicate: predicate object: object.

================
File: examples/named-graphs.st
================
| store graph subject predicate object triple |
store := RDFStore new.
graph := RDFNamedGraph name: 'http://example.org/graph1'.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple toGraph: 'http://example.org/graph1'.

================
File: examples/namespaces.st
================
| ns expandedUri compactUri |
ns := RDFNamespace prefix: 'ex' uri: 'http://example.org/'.
expandedUri := ns expand: 'ex:resource1'.
compactUri := ns compact: 'http://example.org/resource1'.

================
File: examples/print-triple.st
================
Transcript show: triple; cr.

================
File: examples/rdf-dataypes.st
================
| typedLiteral |
typedLiteral := RDFTypedLiteral value: '123' type: 'http://www.w3.org/2001/XMLSchema#integer'.

================
File: examples/store-create-resources-literals.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: repopack.config.json
================
{
    "output": {
        "filePath": "./docs/stonerdf-repopack.txt",
        "headerText": "StoneRDF repo",
        "removeComments": true
    },
    "ignore": {
        "useDefaultPatterns": true,
        "customPatterns": [
            "*.log"
        ]
    }
}

================
File: src/NamedGraph.st
================
Object subclass: RDFNamedGraph [
    | name triples |

    RDFNamedGraph class >> name: aName [
        ^ self new name: aName.
    ]

    name: aName [
        name := aName.
        triples := OrderedCollection new.
    ]

    name [
        ^ name.
    ]

    addTriple: aTriple [
        triples add: aTriple.
    ]

    triplesDo: aBlock [
        triples do: aBlock.
    ]
]

================
File: src/RDFLiteral.st
================
Object subclass: RDFLiteral [
    | value |

    RDFLiteral class >> value: aValue [
        ^ self new value: aValue.
    ]

    value: aValue [
        value := aValue.
    ]

    value [
        ^ value.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFLiteral(', value printString, ')'.
    ]
]

================
File: src/RDFNamespace.st
================
Object subclass: RDFNamespace [
    | prefix uri |

    RDFNamespace class >> prefix: aPrefix uri: anUri [
        ^ self new prefix: aPrefix uri: anUri.
    ]

    prefix: aPrefix uri: anUri [
        prefix := aPrefix.
        uri := anUri.
    ]

    expand: aCompactUri [
        | parts |
        parts := aCompactUri findTokens: ':'.
        ^ (prefix = parts first) ifTrue: [uri, parts second] ifFalse: [aCompactUri].
    ]

    compact: aFullUri [
        ^ (aFullUri beginsWith: uri) ifTrue: [prefix, ':', (aFullUri copyFrom: (uri size + 1) to: aFullUri size)] ifFalse: [aFullUri].
    ]

    prefix [
        ^ prefix.
    ]

    uri [
        ^ uri.
    ]
]

================
File: src/RDFProperty.st
================
RDFResource subclass: RDFProperty [
    printOn: aStream [
        aStream nextPutAll: 'RDFProperty(', self uri, ')'.
    ]
]

================
File: src/RDFResource.st
================
Object subclass: RDFResource [
    | uri |

    RDFResource class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
    ]

    uri [
        ^ uri.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFResource(', uri, ')'.
    ]
]

================
File: src/RDFSClass.st
================
Object subclass: RDFSClass [
    | uri subclasses |

    RDFSClass class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
        subclasses := OrderedCollection new.
    ]

    uri [
        ^ uri.
    ]

    addSubclass: aClass [
        subclasses add: aClass.
    ]

    subclasses [
        ^ subclasses.
    ]

    isSubclassOf: aClass [
        ^ (subclasses includes: aClass) ifTrue: [ true ] ifFalse: [ subclasses anySatisfy: [ :sub | sub isSubclassOf: aClass ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSClass(', uri, ')'.
    ]
]

================
File: src/RDFSProperty.st
================
RDFProperty subclass: RDFSProperty [
    | domain range subproperties |

    RDFSProperty class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        super uri: aString.
        subproperties := OrderedCollection new.
    ]

    domain: aClass [
        domain := aClass.
    ]

    range: aClass [
        range := aClass.
    ]

    domain [
        ^ domain.
    ]

    range [
        ^ range.
    ]

    addSubproperty: aProperty [
        subproperties add: aProperty.
    ]

    subproperties [
        ^ subproperties.
    ]

    isSubpropertyOf: aProperty [
        ^ (subproperties includes: aProperty) ifTrue: [ true ] ifFalse: [ subproperties anySatisfy: [ :sub | sub isSubpropertyOf: aProperty ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSProperty(', self uri, ')'.
    ]

RDFSProperty >> checkDomain: anRDFResource [
    ^ (domain isNil or: [ anRDFResource class isSubclassOf: domain ]) ifFalse: [ self error: 'Domain violation' ].
]

RDFSProperty >> checkRange: anRDFResource [
    ^ (range isNil or: [ anRDFResource class isSubclassOf: range ]) ifFalse: [ self error: 'Range violation' ].
]

]

================
File: src/RDFStore.st
================
Object subclass: RDFStore [
    | triples namedGraphs |

    RDFStore >> initialize [
        triples := OrderedCollection new.
        namedGraphs := Dictionary new.
    ]

    RDFStore >> addTriple: aTriple [
        triples add: aTriple.
    ]

    RDFStore >> addTriple: aTriple toGraph: graphName [
        (namedGraphs at: graphName ifAbsentPut: [RDFNamedGraph name: graphName]) addTriple: aTriple.
    ]

    RDFStore >> triplesDo: aBlock [
        triples do: aBlock.
    ]

    RDFStore >> triplesInGraph: graphName do: aBlock [
        (namedGraphs at: graphName ifAbsent: [^ self]) triplesDo: aBlock.
    ]
]

================
File: src/RDFStoreRDFSInference.st
================
RDFStore >> addTriple: aTriple [
    | predicate subject object |
    subject := aTriple subject.
    predicate := aTriple predicate.
    object := aTriple object.
    "Check domain and range constraints"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate checkDomain: subject.
        predicate checkRange: object.
    ].
    triples add: aTriple.
    "Handle subclass and subproperty inferences"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate subproperties do: [ :sub |
            triples add: (RDFTriple subject: subject predicate: sub object: object).
        ].
    ].
    (subject isKindOf: RDFSClass) ifTrue: [
        subject subclasses do: [ :sub |
            triples add: (RDFTriple subject: sub predicate: predicate object: object).
        ].
    ].
]

================
File: src/RDFTriple.st
================
Object subclass: RDFTriple [
    | subject predicate object |

    RDFTriple class >> subject: aSubject predicate: aPredicate object: anObject [
        ^ self new subject: aSubject predicate: aPredicate object: anObject.
    ]

    subject: aSubject predicate: aPredicate object: anObject [
        subject := aSubject.
        predicate := aPredicate.
        object := anObject.
    ]

    subject [
        ^ subject.
    ]

    predicate [
        ^ predicate.
    ]

    object [
        ^ object.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTriple(', subject printString, ', ', predicate printString, ', ', object printString, ')'.
    ]
]

================
File: src/RDFTypedLiteral.st
================
RDFLiteral subclass: RDFTypedLiteral [
    | datatype |

    RDFTypedLiteral class >> value: aValue type: aDatatypeUri [
        ^ self new value: aValue type: aDatatypeUri.
    ]

    value: aValue type: aDatatypeUri [
        super value: aValue.
        datatype := aDatatypeUri.
    ]

    datatype [
        ^ datatype.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTypedLiteral(', value printString, '^^', datatype, ')'.
    ]
]

================
File: src/SPARQLQuery.st
================
Object subclass: SPARQLQuery [
    | queryString |

    SPARQLQuery class >> query: aString [
        ^ self new query: aString.
    ]

    query: aString [
        queryString := aString.
    ]

    query [
        ^ queryString.
    ]

    executeOn: anRDFStore [
        | results |
        results := OrderedCollection new.
        "Parse the query and match against RDF triples in the store"
        "For simplicity, this example only handles basic SELECT queries with a single triple pattern"
        | subject predicate object pattern |
        (queryString beginsWith: 'SELECT') ifFalse: [ ^ results ].
        pattern := queryString copyFrom: (queryString indexOf: '{') + 1 to: (queryString indexOf: '}') - 1.
        subject := (pattern substrings: ' ') first.
        predicate := (pattern substrings: ' ') second.
        object := (pattern substrings: ' ') third.
        anRDFStore triplesDo: [ :triple |
            ((subject = '?' or: [ triple subject uri = subject ]) and:
             (predicate = '?' or: [ triple predicate uri = predicate ]) and:
             (object = '?' or: [ triple object value = object or: [ triple object uri = object ] ])) ifTrue: [
                results add: triple
            ].
        ].
        ^ results.
    ]
]

================
File: src/define-classes-properties.st
================
| personClass studentClass teachesProperty |
personClass := RDFSClass uri: 'http://example.org/Person'.
studentClass := RDFSClass uri: 'http://example.org/Student'.
personClass addSubclass: studentClass.
teachesProperty := RDFSProperty uri: 'http://example.org/teaches'.
teachesProperty domain: personClass.

================
File: stonerdf-repopack.txt
================
================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-07-27T23:10:46.938Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.
- Code comments have been removed.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

Additional User-Provided Header:
--------------------------------
StoneRDF repo

================================================================
Repository Files
================================================================

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# StoneRDF
it might not happen

================
File: docs/notes.md
================
```
repopack --verbose -c ./repopack.config.json
```

================
File: docs/prompts.md
================
PetitParser:

================
File: examples/create-add-triples.st
================
| store subject predicate object triple |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/Alice'.
predicate := teachesProperty.
object := RDFResource uri: 'http://example.org/Math'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: examples/create-execute-query.st
================
query := SPARQLQuery query: 'SELECT ?s WHERE { ?s <http://example.org/property1> "Some value" }'.
results := store query: query.
Transcript show: results; cr.

================
File: examples/create-resource-literal.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: examples/create-triple.st
================
triple := RDFTriple subject: subject predicate: predicate object: object.

================
File: examples/named-graphs.st
================
| store graph subject predicate object triple |
store := RDFStore new.
graph := RDFNamedGraph name: 'http://example.org/graph1'.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple toGraph: 'http://example.org/graph1'.

================
File: examples/namespaces.st
================
| ns expandedUri compactUri |
ns := RDFNamespace prefix: 'ex' uri: 'http://example.org/'.
expandedUri := ns expand: 'ex:resource1'.
compactUri := ns compact: 'http://example.org/resource1'.

================
File: examples/print-triple.st
================
Transcript show: triple; cr.

================
File: examples/rdf-dataypes.st
================
| typedLiteral |
typedLiteral := RDFTypedLiteral value: '123' type: 'http://www.w3.org/2001/XMLSchema#integer'.

================
File: examples/store-create-resources-literals.st
================
| store subject predicate object triple query results |
store := RDFStore new.
subject := RDFResource uri: 'http://example.org/resource1'.
predicate := RDFProperty uri: 'http://example.org/property1'.
object := RDFLiteral value: 'Some value'.
triple := RDFTriple subject: subject predicate: predicate object: object.
store addTriple: triple.

================
File: repopack.config.json
================
{
    "output": {
        "filePath": "./docs/stonerdf-repopack.txt",
        "headerText": "StoneRDF repo",
        "removeComments": true
    },
    "ignore": {
        "useDefaultPatterns": true,
        "customPatterns": [
            "*.log"
        ]
    }
}

================
File: src/NamedGraph.st
================
Object subclass: RDFNamedGraph [
    | name triples |

    RDFNamedGraph class >> name: aName [
        ^ self new name: aName.
    ]

    name: aName [
        name := aName.
        triples := OrderedCollection new.
    ]

    name [
        ^ name.
    ]

    addTriple: aTriple [
        triples add: aTriple.
    ]

    triplesDo: aBlock [
        triples do: aBlock.
    ]
]

================
File: src/RDFLiteral.st
================
Object subclass: RDFLiteral [
    | value |

    RDFLiteral class >> value: aValue [
        ^ self new value: aValue.
    ]

    value: aValue [
        value := aValue.
    ]

    value [
        ^ value.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFLiteral(', value printString, ')'.
    ]
]

================
File: src/RDFNamespace.st
================
Object subclass: RDFNamespace [
    | prefix uri |

    RDFNamespace class >> prefix: aPrefix uri: anUri [
        ^ self new prefix: aPrefix uri: anUri.
    ]

    prefix: aPrefix uri: anUri [
        prefix := aPrefix.
        uri := anUri.
    ]

    expand: aCompactUri [
        | parts |
        parts := aCompactUri findTokens: ':'.
        ^ (prefix = parts first) ifTrue: [uri, parts second] ifFalse: [aCompactUri].
    ]

    compact: aFullUri [
        ^ (aFullUri beginsWith: uri) ifTrue: [prefix, ':', (aFullUri copyFrom: (uri size + 1) to: aFullUri size)] ifFalse: [aFullUri].
    ]

    prefix [
        ^ prefix.
    ]

    uri [
        ^ uri.
    ]
]

================
File: src/RDFProperty.st
================
RDFResource subclass: RDFProperty [
    printOn: aStream [
        aStream nextPutAll: 'RDFProperty(', self uri, ')'.
    ]
]

================
File: src/RDFResource.st
================
Object subclass: RDFResource [
    | uri |

    RDFResource class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
    ]

    uri [
        ^ uri.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFResource(', uri, ')'.
    ]
]

================
File: src/RDFSClass.st
================
Object subclass: RDFSClass [
    | uri subclasses |

    RDFSClass class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        uri := aString.
        subclasses := OrderedCollection new.
    ]

    uri [
        ^ uri.
    ]

    addSubclass: aClass [
        subclasses add: aClass.
    ]

    subclasses [
        ^ subclasses.
    ]

    isSubclassOf: aClass [
        ^ (subclasses includes: aClass) ifTrue: [ true ] ifFalse: [ subclasses anySatisfy: [ :sub | sub isSubclassOf: aClass ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSClass(', uri, ')'.
    ]
]

================
File: src/RDFSProperty.st
================
RDFProperty subclass: RDFSProperty [
    | domain range subproperties |

    RDFSProperty class >> uri: aString [
        ^ self new uri: aString.
    ]

    uri: aString [
        super uri: aString.
        subproperties := OrderedCollection new.
    ]

    domain: aClass [
        domain := aClass.
    ]

    range: aClass [
        range := aClass.
    ]

    domain [
        ^ domain.
    ]

    range [
        ^ range.
    ]

    addSubproperty: aProperty [
        subproperties add: aProperty.
    ]

    subproperties [
        ^ subproperties.
    ]

    isSubpropertyOf: aProperty [
        ^ (subproperties includes: aProperty) ifTrue: [ true ] ifFalse: [ subproperties anySatisfy: [ :sub | sub isSubpropertyOf: aProperty ] ].
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFSProperty(', self uri, ')'.
    ]

RDFSProperty >> checkDomain: anRDFResource [
    ^ (domain isNil or: [ anRDFResource class isSubclassOf: domain ]) ifFalse: [ self error: 'Domain violation' ].
]

RDFSProperty >> checkRange: anRDFResource [
    ^ (range isNil or: [ anRDFResource class isSubclassOf: range ]) ifFalse: [ self error: 'Range violation' ].
]

]

================
File: src/RDFStore.st
================
Object subclass: RDFStore [
    | triples namedGraphs |

    RDFStore >> initialize [
        triples := OrderedCollection new.
        namedGraphs := Dictionary new.
    ]

    RDFStore >> addTriple: aTriple [
        triples add: aTriple.
    ]

    RDFStore >> addTriple: aTriple toGraph: graphName [
        (namedGraphs at: graphName ifAbsentPut: [RDFNamedGraph name: graphName]) addTriple: aTriple.
    ]

    RDFStore >> triplesDo: aBlock [
        triples do: aBlock.
    ]

    RDFStore >> triplesInGraph: graphName do: aBlock [
        (namedGraphs at: graphName ifAbsent: [^ self]) triplesDo: aBlock.
    ]
]

================
File: src/RDFStoreRDFSInference.st
================
RDFStore >> addTriple: aTriple [
    | predicate subject object |
    subject := aTriple subject.
    predicate := aTriple predicate.
    object := aTriple object.
    "Check domain and range constraints"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate checkDomain: subject.
        predicate checkRange: object.
    ].
    triples add: aTriple.
    "Handle subclass and subproperty inferences"
    (predicate isKindOf: RDFSProperty) ifTrue: [
        predicate subproperties do: [ :sub |
            triples add: (RDFTriple subject: subject predicate: sub object: object).
        ].
    ].
    (subject isKindOf: RDFSClass) ifTrue: [
        subject subclasses do: [ :sub |
            triples add: (RDFTriple subject: sub predicate: predicate object: object).
        ].
    ].
]

================
File: src/RDFTriple.st
================
Object subclass: RDFTriple [
    | subject predicate object |

    RDFTriple class >> subject: aSubject predicate: aPredicate object: anObject [
        ^ self new subject: aSubject predicate: aPredicate object: anObject.
    ]

    subject: aSubject predicate: aPredicate object: anObject [
        subject := aSubject.
        predicate := aPredicate.
        object := anObject.
    ]

    subject [
        ^ subject.
    ]

    predicate [
        ^ predicate.
    ]

    object [
        ^ object.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTriple(', subject printString, ', ', predicate printString, ', ', object printString, ')'.
    ]
]

================
File: src/RDFTypedLiteral.st
================
RDFLiteral subclass: RDFTypedLiteral [
    | datatype |

    RDFTypedLiteral class >> value: aValue type: aDatatypeUri [
        ^ self new value: aValue type: aDatatypeUri.
    ]

    value: aValue type: aDatatypeUri [
        super value: aValue.
        datatype := aDatatypeUri.
    ]

    datatype [
        ^ datatype.
    ]

    printOn: aStream [
        aStream nextPutAll: 'RDFTypedLiteral(', value printString, '^^', datatype, ')'.
    ]
]

================
File: src/SPARQLQuery.st
================
Object subclass: SPARQLQuery [
    | queryString |

    SPARQLQuery class >> query: aString [
        ^ self new query: aString.
    ]

    query: aString [
        queryString := aString.
    ]

    query [
        ^ queryString.
    ]

    executeOn: anRDFStore [
        | results |
        results := OrderedCollection new.
        "Parse the query and match against RDF triples in the store"
        "For simplicity, this example only handles basic SELECT queries with a single triple pattern"
        | subject predicate object pattern |
        (queryString beginsWith: 'SELECT') ifFalse: [ ^ results ].
        pattern := queryString copyFrom: (queryString indexOf: '{') + 1 to: (queryString indexOf: '}') - 1.
        subject := (pattern substrings: ' ') first.
        predicate := (pattern substrings: ' ') second.
        object := (pattern substrings: ' ') third.
        anRDFStore triplesDo: [ :triple |
            ((subject = '?' or: [ triple subject uri = subject ]) and:
             (predicate = '?' or: [ triple predicate uri = predicate ]) and:
             (object = '?' or: [ triple object value = object or: [ triple object uri = object ] ])) ifTrue: [
                results add: triple
            ].
        ].
        ^ results.
    ]
]

================
File: src/define-classes-properties.st
================
| personClass studentClass teachesProperty |
personClass := RDFSClass uri: 'http://example.org/Person'.
studentClass := RDFSClass uri: 'http://example.org/Student'.
personClass addSubclass: studentClass.
teachesProperty := RDFSProperty uri: 'http://example.org/teaches'.
teachesProperty domain: personClass.
